"""
    Randori API SDK

    A python client library for accessing Randori API endpoints using API tokens  # noqa: E501

    The version of the OpenAPI document: 1.0
    Contact: support@randori.com
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from randori_api_sdk.api_client import ApiClient, Endpoint as _Endpoint
from randori_api_sdk.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from randori_api_sdk.model.action_metadata_get_output import ActionMetadataGetOutput
from randori_api_sdk.model.action_metadata_single_output import ActionMetadataSingleOutput
from randori_api_sdk.model.activity_log_get_output import ActivityLogGetOutput
from randori_api_sdk.model.activity_log_single_output import ActivityLogSingleOutput
from randori_api_sdk.model.all_detections_for_target_get_output import AllDetectionsForTargetGetOutput
from randori_api_sdk.model.artifact_for_activity_response_collection_schema import ArtifactForActivityResponseCollectionSchema
from randori_api_sdk.model.attack_checkins_for_implant_get_output import AttackCheckinsForImplantGetOutput
from randori_api_sdk.model.attack_implants_get_output import AttackImplantsGetOutput
from randori_api_sdk.model.attack_implants_single_output import AttackImplantsSingleOutput
from randori_api_sdk.model.attack_interfaces_for_implant_get_output import AttackInterfacesForImplantGetOutput
from randori_api_sdk.model.attack_redirectors_get_output import AttackRedirectorsGetOutput
from randori_api_sdk.model.attack_runbook_get_output import AttackRunbookGetOutput
from randori_api_sdk.model.attack_statistics_get_output import AttackStatisticsGetOutput
from randori_api_sdk.model.authorization_policy_get_output import AuthorizationPolicyGetOutput
from randori_api_sdk.model.comment_creation_schema import CommentCreationSchema
from randori_api_sdk.model.comment_response_collection_schema import CommentResponseCollectionSchema
from randori_api_sdk.model.comment_response_schema import CommentResponseSchema
from randori_api_sdk.model.default_output_schema import DefaultOutputSchema
from randori_api_sdk.model.error_schema import ErrorSchema
from randori_api_sdk.model.external_comment_creation_schema import ExternalCommentCreationSchema
from randori_api_sdk.model.feature_response_collection import FeatureResponseCollection
from randori_api_sdk.model.hostname_get_output import HostnameGetOutput
from randori_api_sdk.model.hostname_patch_input import HostnamePatchInput
from randori_api_sdk.model.hostname_patch_output import HostnamePatchOutput
from randori_api_sdk.model.hostname_single_output import HostnameSingleOutput
from randori_api_sdk.model.hostnames_for_ip_get_output import HostnamesForIpGetOutput
from randori_api_sdk.model.hostnames_for_ip_single_output import HostnamesForIpSingleOutput
from randori_api_sdk.model.ip_get_output import IpGetOutput
from randori_api_sdk.model.ip_patch_input import IpPatchInput
from randori_api_sdk.model.ip_patch_output import IpPatchOutput
from randori_api_sdk.model.ip_single_output import IpSingleOutput
from randori_api_sdk.model.ips_for_hostname_get_output import IpsForHostnameGetOutput
from randori_api_sdk.model.ips_for_hostname_single_output import IpsForHostnameSingleOutput
from randori_api_sdk.model.ips_for_network_get_output import IpsForNetworkGetOutput
from randori_api_sdk.model.ips_for_network_single_output import IpsForNetworkSingleOutput
from randori_api_sdk.model.ips_for_service_get_output import IpsForServiceGetOutput
from randori_api_sdk.model.ips_for_service_single_output import IpsForServiceSingleOutput
from randori_api_sdk.model.logout_input_schema import LogoutInputSchema
from randori_api_sdk.model.manual_authorization_request import ManualAuthorizationRequest
from randori_api_sdk.model.mitre_mitigation import MitreMitigation
from randori_api_sdk.model.mitre_tactic import MitreTactic
from randori_api_sdk.model.mitre_technique import MitreTechnique
from randori_api_sdk.model.network_get_output import NetworkGetOutput
from randori_api_sdk.model.network_patch_input import NetworkPatchInput
from randori_api_sdk.model.network_patch_output import NetworkPatchOutput
from randori_api_sdk.model.network_single_output import NetworkSingleOutput
from randori_api_sdk.model.org_feature_response_collection import OrgFeatureResponseCollection
from randori_api_sdk.model.org_with_feature_response_collection import OrgWithFeatureResponseCollection
from randori_api_sdk.model.organization_get_output import OrganizationGetOutput
from randori_api_sdk.model.organization_single_output import OrganizationSingleOutput
from randori_api_sdk.model.otp_token_input_schema import OtpTokenInputSchema
from randori_api_sdk.model.password_change_schema import PasswordChangeSchema
from randori_api_sdk.model.paths_output_schema import PathsOutputSchema
from randori_api_sdk.model.permission_group import PermissionGroup
from randori_api_sdk.model.permission_groups_info import PermissionGroupsInfo
from randori_api_sdk.model.policy_get_output import PolicyGetOutput
from randori_api_sdk.model.ports_for_ip_get_output import PortsForIpGetOutput
from randori_api_sdk.model.ports_for_ip_single_output import PortsForIpSingleOutput
from randori_api_sdk.model.preference_out_collection import PreferenceOutCollection
from randori_api_sdk.model.recon_worker_node_ips import ReconWorkerNodeIps
from randori_api_sdk.model.saved_views_get_output import SavedViewsGetOutput
from randori_api_sdk.model.saved_views_patch_single_input import SavedViewsPatchSingleInput
from randori_api_sdk.model.saved_views_post_input import SavedViewsPostInput
from randori_api_sdk.model.saved_views_post_output import SavedViewsPostOutput
from randori_api_sdk.model.saved_views_single_input import SavedViewsSingleInput
from randori_api_sdk.model.saved_views_single_output import SavedViewsSingleOutput
from randori_api_sdk.model.service_get_output import ServiceGetOutput
from randori_api_sdk.model.service_single_output import ServiceSingleOutput
from randori_api_sdk.model.single_detection_for_target_get_output import SingleDetectionForTargetGetOutput
from randori_api_sdk.model.social_entity_get_output import SocialEntityGetOutput
from randori_api_sdk.model.social_entity_patch_input import SocialEntityPatchInput
from randori_api_sdk.model.social_entity_patch_output import SocialEntityPatchOutput
from randori_api_sdk.model.statistics_get_output import StatisticsGetOutput
from randori_api_sdk.model.tagcounts_get_output import TagcountsGetOutput
from randori_api_sdk.model.tagcounts_single_output import TagcountsSingleOutput
from randori_api_sdk.model.target_get_output import TargetGetOutput
from randori_api_sdk.model.target_patch_input import TargetPatchInput
from randori_api_sdk.model.target_patch_output import TargetPatchOutput
from randori_api_sdk.model.target_single_output import TargetSingleOutput
from randori_api_sdk.model.token_input_schema import TokenInputSchema
from randori_api_sdk.model.token_output_schema import TokenOutputSchema
from randori_api_sdk.model.user_get_output import UserGetOutput
from randori_api_sdk.model.user_patch_single_input import UserPatchSingleInput
from randori_api_sdk.model.user_single_output import UserSingleOutput
from randori_api_sdk.model.user_tag_name_list import UserTagNameList
from randori_api_sdk.model.username_password_input_schema import UsernamePasswordInputSchema


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.add_affiliation_file_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/artifactstore/api/v1/add_affiliation_file',
                'operation_id': 'add_affiliation_file',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.artifacts_endpoint = _Endpoint(
            settings={
                'response_type': (ArtifactForActivityResponseCollectionSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/artifactstore/api/v1/activity-log/{activity_instance_id}/artifacts',
                'operation_id': 'artifacts',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'activity_instance_id',
                    'offset',
                    'limit',
                ],
                'required': [
                    'activity_instance_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'activity_instance_id':
                        (str,),
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                },
                'attribute_map': {
                    'activity_instance_id': 'activity_instance_id',
                    'offset': 'offset',
                    'limit': 'limit',
                },
                'location_map': {
                    'activity_instance_id': 'path',
                    'offset': 'query',
                    'limit': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.change_password_endpoint = _Endpoint(
            settings={
                'response_type': (DefaultOutputSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/change-password',
                'operation_id': 'change_password',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'password_change_schema',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'password_change_schema':
                        (PasswordChangeSchema,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'password_change_schema': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.delete_comment_endpoint = _Endpoint(
            settings={
                'response_type': (CommentResponseSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/entity/{entity_id}/comment/{comment_id}',
                'operation_id': 'delete_comment',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'comment_id',
                    'entity_id',
                ],
                'required': [
                    'comment_id',
                    'entity_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'comment_id':
                        (str,),
                    'entity_id':
                        (str,),
                },
                'attribute_map': {
                    'comment_id': 'comment_id',
                    'entity_id': 'entity_id',
                },
                'location_map': {
                    'comment_id': 'path',
                    'entity_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_single_saved_views_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/saved-views/{id}',
                'operation_id': 'delete_single_saved_views',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'saved_views_single_input',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'saved_views_single_input':
                        (SavedViewsSingleInput,),
                },
                'attribute_map': {
                    'id': 'id',
                },
                'location_map': {
                    'id': 'path',
                    'saved_views_single_input': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.features_endpoint = _Endpoint(
            settings={
                'response_type': (FeatureResponseCollection,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/features',
                'operation_id': 'features',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'feature_names',
                    'feature_types',
                    'active_only',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'feature_names':
                        ([str],),
                    'feature_types':
                        ([str],),
                    'active_only':
                        (bool,),
                },
                'attribute_map': {
                    'feature_names': 'feature_names',
                    'feature_types': 'feature_types',
                    'active_only': 'active_only',
                },
                'location_map': {
                    'feature_names': 'query',
                    'feature_types': 'query',
                    'active_only': 'query',
                },
                'collection_format_map': {
                    'feature_names': 'multi',
                    'feature_types': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.features_org_endpoint = _Endpoint(
            settings={
                'response_type': (OrgFeatureResponseCollection,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/features-org',
                'operation_id': 'features_org',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'names',
                    'org_uuid',
                    'active_only',
                    'return_all',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'names':
                        ([str],),
                    'org_uuid':
                        (str,),
                    'active_only':
                        (bool,),
                    'return_all':
                        (bool,),
                },
                'attribute_map': {
                    'names': 'names',
                    'org_uuid': 'org_uuid',
                    'active_only': 'active_only',
                    'return_all': 'return_all',
                },
                'location_map': {
                    'names': 'query',
                    'org_uuid': 'query',
                    'active_only': 'query',
                    'return_all': 'query',
                },
                'collection_format_map': {
                    'names': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_action_metadata_endpoint = _Endpoint(
            settings={
                'response_type': (ActionMetadataGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/attack/api/v1/user/actions',
                'operation_id': 'get_action_metadata',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-ACTION_ID": "-action_id",
                        "-ARTIFACTS_STATUS": "-artifacts_status",
                        "-BART_ID": "-bart_id",
                        "-COMPLETED": "-completed",
                        "-CONFIG_HASH": "-config_hash",
                        "-CREATED": "-created",
                        "-DELETED": "-deleted",
                        "-DESCRIPTION": "-description",
                        "-DESCRIPTION_ID": "-description_id",
                        "-DISPLAY_NAME": "-display_name",
                        "-DST_EMAIL": "-dst_email",
                        "-DST_HOST": "-dst_host",
                        "-DST_IP": "-dst_ip",
                        "-DST_MAC": "-dst_mac",
                        "-DST_MISC": "-dst_misc",
                        "-DST_NETWORK": "-dst_network",
                        "-DST_PATH": "-dst_path",
                        "-DST_PORT": "-dst_port",
                        "-ID": "-id",
                        "-IMPLANT_ID": "-implant_id",
                        "-IMPLANT_NICK": "-implant_nick",
                        "-IMPLANT_UID": "-implant_uid",
                        "-MITRE_TECHNIQUES": "-mitre_techniques",
                        "-NAME": "-name",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE_METADATA": "-perspective_metadata",
                        "-RANDORI_NOTES": "-randori_notes",
                        "-RESULT": "-result",
                        "-RESULT_HASH": "-result_hash",
                        "-RUNBOOK_INSTANCE_ID": "-runbook_instance_id",
                        "-SRC_EMAIL": "-src_email",
                        "-SRC_HOST": "-src_host",
                        "-SRC_IP": "-src_ip",
                        "-SRC_MAC": "-src_mac",
                        "-SRC_MISC": "-src_misc",
                        "-STABILITY": "-stability",
                        "-STARTED": "-started",
                        "-STEALTH": "-stealth",
                        "-SUMMARY_SHA": "-summary_sha",
                        "-TEMPLATE": "-template",
                        "-TRIGGER": "-trigger",
                        "-UPDATED": "-updated",
                        "ACTION_ID": "action_id",
                        "ARTIFACTS_STATUS": "artifacts_status",
                        "BART_ID": "bart_id",
                        "COMPLETED": "completed",
                        "CONFIG_HASH": "config_hash",
                        "CREATED": "created",
                        "DELETED": "deleted",
                        "DESCRIPTION": "description",
                        "DESCRIPTION_ID": "description_id",
                        "DISPLAY_NAME": "display_name",
                        "DST_EMAIL": "dst_email",
                        "DST_HOST": "dst_host",
                        "DST_IP": "dst_ip",
                        "DST_MAC": "dst_mac",
                        "DST_MISC": "dst_misc",
                        "DST_NETWORK": "dst_network",
                        "DST_PATH": "dst_path",
                        "DST_PORT": "dst_port",
                        "ID": "id",
                        "IMPLANT_ID": "implant_id",
                        "IMPLANT_NICK": "implant_nick",
                        "IMPLANT_UID": "implant_uid",
                        "MITRE_TECHNIQUES": "mitre_techniques",
                        "NAME": "name",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE_METADATA": "perspective_metadata",
                        "RANDORI_NOTES": "randori_notes",
                        "RESULT": "result",
                        "RESULT_HASH": "result_hash",
                        "RUNBOOK_INSTANCE_ID": "runbook_instance_id",
                        "SRC_EMAIL": "src_email",
                        "SRC_HOST": "src_host",
                        "SRC_IP": "src_ip",
                        "SRC_MAC": "src_mac",
                        "SRC_MISC": "src_misc",
                        "STABILITY": "stability",
                        "STARTED": "started",
                        "STEALTH": "stealth",
                        "SUMMARY_SHA": "summary_sha",
                        "TEMPLATE": "template",
                        "TRIGGER": "trigger",
                        "UPDATED": "updated"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_activity_log_endpoint = _Endpoint(
            settings={
                'response_type': (ActivityLogGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/activity-log',
                'operation_id': 'get_activity_log',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-CONFIGURATION__DESCRIPTION": "-configuration__description",
                        "-CONFIGURATION__ID": "-configuration__id",
                        "-CONFIGURATION__NAME": "-configuration__name",
                        "-CONFIGURATION__VERSION_ID": "-configuration__version_id",
                        "-COUNT__ARTIFACTS": "-count__artifacts",
                        "-COUNT__ENTITIES_UPDATED": "-count__entities_updated",
                        "-COUNT__RELATIONSHIPS_DELETED": "-count__relationships_deleted",
                        "-ID": "-id",
                        "-INSTANCE__MOST_RECENT_INSTANCE_ID": "-instance__most_recent_instance_id",
                        "-INSTANCE__PERSPECTIVE": "-instance__perspective",
                        "-INSTANCE__STATE": "-instance__state",
                        "-INSTANCE__TIME_DURATION": "-instance__time_duration",
                        "-INSTANCE__TIME_END": "-instance__time_end",
                        "-INSTANCE__TIME_START": "-instance__time_start",
                        "-MATCHING_ENTITY__DETECTION": "-matching_entity__detection",
                        "-MATCHING_ENTITY__EMAIL": "-matching_entity__email",
                        "-MATCHING_ENTITY__HOSTNAME": "-matching_entity__hostname",
                        "-MATCHING_ENTITY__ID": "-matching_entity__id",
                        "-MATCHING_ENTITY__IP": "-matching_entity__ip",
                        "-MATCHING_ENTITY__NAME": "-matching_entity__name",
                        "-MATCHING_ENTITY__NETWORK": "-matching_entity__network",
                        "-MATCHING_ENTITY__TARGET": "-matching_entity__target",
                        "-MATCHING_ENTITY__TERM": "-matching_entity__term",
                        "-MATCHING_ENTITY__TYPE": "-matching_entity__type",
                        "-MITRE__MITIGATIONS": "-mitre__mitigations",
                        "-MITRE__TACTICS": "-mitre__tactics",
                        "-MITRE__TECHNIQUES": "-mitre__techniques",
                        "-OBJECTIVE__ATTACKER_PERSPECTIVE": "-objective__attacker_perspective",
                        "-OBJECTIVE__DESCRIPTION": "-objective__description",
                        "-OBJECTIVE__IMPLICATION": "-objective__implication",
                        "-OBJECTIVE__STATUS": "-objective__status",
                        "-ORG_ID": "-org_id",
                        "-TRAFFIC_DESTINATION": "-traffic_destination",
                        "-TRAFFIC_DESTINATION_DETAIL": "-traffic_destination_detail",
                        "-TRAFFIC_SOURCE__IP_NAME": "-traffic_source__ip_name",
                        "CONFIGURATION__DESCRIPTION": "configuration__description",
                        "CONFIGURATION__ID": "configuration__id",
                        "CONFIGURATION__NAME": "configuration__name",
                        "CONFIGURATION__VERSION_ID": "configuration__version_id",
                        "COUNT__ARTIFACTS": "count__artifacts",
                        "COUNT__ENTITIES_UPDATED": "count__entities_updated",
                        "COUNT__RELATIONSHIPS_DELETED": "count__relationships_deleted",
                        "ID": "id",
                        "INSTANCE__MOST_RECENT_INSTANCE_ID": "instance__most_recent_instance_id",
                        "INSTANCE__PERSPECTIVE": "instance__perspective",
                        "INSTANCE__STATE": "instance__state",
                        "INSTANCE__TIME_DURATION": "instance__time_duration",
                        "INSTANCE__TIME_END": "instance__time_end",
                        "INSTANCE__TIME_START": "instance__time_start",
                        "MATCHING_ENTITY__DETECTION": "matching_entity__detection",
                        "MATCHING_ENTITY__EMAIL": "matching_entity__email",
                        "MATCHING_ENTITY__HOSTNAME": "matching_entity__hostname",
                        "MATCHING_ENTITY__ID": "matching_entity__id",
                        "MATCHING_ENTITY__IP": "matching_entity__ip",
                        "MATCHING_ENTITY__NAME": "matching_entity__name",
                        "MATCHING_ENTITY__NETWORK": "matching_entity__network",
                        "MATCHING_ENTITY__TARGET": "matching_entity__target",
                        "MATCHING_ENTITY__TERM": "matching_entity__term",
                        "MATCHING_ENTITY__TYPE": "matching_entity__type",
                        "MITRE__MITIGATIONS": "mitre__mitigations",
                        "MITRE__TACTICS": "mitre__tactics",
                        "MITRE__TECHNIQUES": "mitre__techniques",
                        "OBJECTIVE__ATTACKER_PERSPECTIVE": "objective__attacker_perspective",
                        "OBJECTIVE__DESCRIPTION": "objective__description",
                        "OBJECTIVE__IMPLICATION": "objective__implication",
                        "OBJECTIVE__STATUS": "objective__status",
                        "ORG_ID": "org_id",
                        "TRAFFIC_DESTINATION": "traffic_destination",
                        "TRAFFIC_DESTINATION_DETAIL": "traffic_destination_detail",
                        "TRAFFIC_SOURCE__IP_NAME": "traffic_source__ip_name"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_all_detections_for_target_endpoint = _Endpoint(
            settings={
                'response_type': (AllDetectionsForTargetGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/all-detections-for-target',
                'operation_id': 'get_all_detections_for_target',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-AFFILIATION_STATE": "-affiliation_state",
                        "-APPLICABILITY": "-applicability",
                        "-ATTACK_NOTE": "-attack_note",
                        "-AUTHORITY": "-authority",
                        "-AUTHORITY_DISTANCE": "-authority_distance",
                        "-AUTHORITY_OVERRIDE": "-authority_override",
                        "-AUTHORIZATION_STATE": "-authorization_state",
                        "-AUTHORIZING_POLICIES": "-authorizing_policies",
                        "-BANNERS_UUID": "-banners_uuid",
                        "-CERT_UUID": "-cert_uuid",
                        "-CHARACTERISTIC_TAGS": "-characteristic_tags",
                        "-CHARACTERISTICS_COUNT": "-characteristics_count",
                        "-CONFIDENCE": "-confidence",
                        "-CPE": "-cpe",
                        "-CRITICALITY": "-criticality",
                        "-DELETED": "-deleted",
                        "-DESCRIPTION": "-description",
                        "-DESCRIPTION_SOURCE": "-description_source",
                        "-DETECTION_AUTHORIZATION_STATE": "-detection_authorization_state",
                        "-DETECTION_CRITERIA": "-detection_criteria",
                        "-DETECTION_RELEVANCE": "-detection_relevance",
                        "-DETECTION_UUID": "-detection_uuid",
                        "-ENUMERABILITY": "-enumerability",
                        "-EXPLOITABILITY": "-exploitability",
                        "-FIRST_SEEN": "-first_seen",
                        "-HEADERS_UUID": "-headers_uuid",
                        "-HOSTNAME": "-hostname",
                        "-HOSTNAME_ID": "-hostname_id",
                        "-ID": "-id",
                        "-IMPACT_SCORE": "-impact_score",
                        "-IP": "-ip",
                        "-IP_ID": "-ip_id",
                        "-IP_STR": "-ip_str",
                        "-LAST_SEEN": "-last_seen",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-NAME": "-name",
                        "-ORG_ID": "-org_id",
                        "-PATH": "-path",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-POC_EMAIL": "-poc_email",
                        "-POC_ID": "-poc_id",
                        "-PORT": "-port",
                        "-POST_EXPLOIT": "-post_exploit",
                        "-PRIORITY_IMPACT_FACTOR": "-priority_impact_factor",
                        "-PRIORITY_SCORE": "-priority_score",
                        "-PRIORITY_STATUS_FACTOR": "-priority_status_factor",
                        "-PRIORITY_TAGS_FACTOR": "-priority_tags_factor",
                        "-PRIVATE_WEAKNESS": "-private_weakness",
                        "-PROTOCOL": "-protocol",
                        "-PUBLIC_WEAKNESS": "-public_weakness",
                        "-RANDORI_NOTES": "-randori_notes",
                        "-REFERENCE": "-reference",
                        "-RESEARCH": "-research",
                        "-SCREENSHOT_UUID": "-screenshot_uuid",
                        "-SERVICE_ID": "-service_id",
                        "-STATUS": "-status",
                        "-TARGET_CONFIDENCE": "-target_confidence",
                        "-TARGET_FIRST_SEEN": "-target_first_seen",
                        "-TARGET_ID": "-target_id",
                        "-TARGET_LAST_SEEN": "-target_last_seen",
                        "-TARGET_NUM_AUTHORIZED_DETECTIONS": "-target_num_authorized_detections",
                        "-TARGET_NUM_DETECTIONS": "-target_num_detections",
                        "-TARGET_TEMPTATION": "-target_temptation",
                        "-TECH_CATEGORY": "-tech_category",
                        "-TEMPTATION_LAST_MODIFIED": "-temptation_last_modified",
                        "-THUMBNAIL_UUID": "-thumbnail_uuid",
                        "-USER_TAGS": "-user_tags",
                        "-VALIDATED_VULNERABILITIES_DETECTION": "-validated_vulnerabilities_detection",
                        "-VALIDATED_VULNERABILITIES_DETECTION_COUNT": "-validated_vulnerabilities_detection_count",
                        "-VALIDATED_VULNERABILITIES_TARGET": "-validated_vulnerabilities_target",
                        "-VALIDATED_VULNERABILITIES_TARGET_COUNT": "-validated_vulnerabilities_target_count",
                        "-VENDOR": "-vendor",
                        "-VERSION": "-version",
                        "AFFILIATION_STATE": "affiliation_state",
                        "APPLICABILITY": "applicability",
                        "ATTACK_NOTE": "attack_note",
                        "AUTHORITY": "authority",
                        "AUTHORITY_DISTANCE": "authority_distance",
                        "AUTHORITY_OVERRIDE": "authority_override",
                        "AUTHORIZATION_STATE": "authorization_state",
                        "AUTHORIZING_POLICIES": "authorizing_policies",
                        "BANNERS_UUID": "banners_uuid",
                        "CERT_UUID": "cert_uuid",
                        "CHARACTERISTIC_TAGS": "characteristic_tags",
                        "CHARACTERISTICS_COUNT": "characteristics_count",
                        "CONFIDENCE": "confidence",
                        "CPE": "cpe",
                        "CRITICALITY": "criticality",
                        "DELETED": "deleted",
                        "DESCRIPTION": "description",
                        "DESCRIPTION_SOURCE": "description_source",
                        "DETECTION_AUTHORIZATION_STATE": "detection_authorization_state",
                        "DETECTION_CRITERIA": "detection_criteria",
                        "DETECTION_RELEVANCE": "detection_relevance",
                        "DETECTION_UUID": "detection_uuid",
                        "ENUMERABILITY": "enumerability",
                        "EXPLOITABILITY": "exploitability",
                        "FIRST_SEEN": "first_seen",
                        "HEADERS_UUID": "headers_uuid",
                        "HOSTNAME": "hostname",
                        "HOSTNAME_ID": "hostname_id",
                        "ID": "id",
                        "IMPACT_SCORE": "impact_score",
                        "IP": "ip",
                        "IP_ID": "ip_id",
                        "IP_STR": "ip_str",
                        "LAST_SEEN": "last_seen",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "NAME": "name",
                        "ORG_ID": "org_id",
                        "PATH": "path",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "POC_EMAIL": "poc_email",
                        "POC_ID": "poc_id",
                        "PORT": "port",
                        "POST_EXPLOIT": "post_exploit",
                        "PRIORITY_IMPACT_FACTOR": "priority_impact_factor",
                        "PRIORITY_SCORE": "priority_score",
                        "PRIORITY_STATUS_FACTOR": "priority_status_factor",
                        "PRIORITY_TAGS_FACTOR": "priority_tags_factor",
                        "PRIVATE_WEAKNESS": "private_weakness",
                        "PROTOCOL": "protocol",
                        "PUBLIC_WEAKNESS": "public_weakness",
                        "RANDORI_NOTES": "randori_notes",
                        "REFERENCE": "reference",
                        "RESEARCH": "research",
                        "SCREENSHOT_UUID": "screenshot_uuid",
                        "SERVICE_ID": "service_id",
                        "STATUS": "status",
                        "TARGET_CONFIDENCE": "target_confidence",
                        "TARGET_FIRST_SEEN": "target_first_seen",
                        "TARGET_ID": "target_id",
                        "TARGET_LAST_SEEN": "target_last_seen",
                        "TARGET_NUM_AUTHORIZED_DETECTIONS": "target_num_authorized_detections",
                        "TARGET_NUM_DETECTIONS": "target_num_detections",
                        "TARGET_TEMPTATION": "target_temptation",
                        "TECH_CATEGORY": "tech_category",
                        "TEMPTATION_LAST_MODIFIED": "temptation_last_modified",
                        "THUMBNAIL_UUID": "thumbnail_uuid",
                        "USER_TAGS": "user_tags",
                        "VALIDATED_VULNERABILITIES_DETECTION": "validated_vulnerabilities_detection",
                        "VALIDATED_VULNERABILITIES_DETECTION_COUNT": "validated_vulnerabilities_detection_count",
                        "VALIDATED_VULNERABILITIES_TARGET": "validated_vulnerabilities_target",
                        "VALIDATED_VULNERABILITIES_TARGET_COUNT": "validated_vulnerabilities_target_count",
                        "VENDOR": "vendor",
                        "VERSION": "version"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_attack_checkins_for_implant_endpoint = _Endpoint(
            settings={
                'response_type': (AttackCheckinsForImplantGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/attack/api/v1/user/checkins-for-implant',
                'operation_id': 'get_attack_checkins_for_implant',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-BART_ID": "-bart_id",
                        "-ID": "-id",
                        "-IMPLANT_ID": "-implant_id",
                        "-LAST_CHECKIN": "-last_checkin",
                        "-METHOD": "-method",
                        "-ORG_ID": "-org_id",
                        "-SRC_IP": "-src_ip",
                        "-SRC_IP_STR": "-src_ip_str",
                        "BART_ID": "bart_id",
                        "ID": "id",
                        "IMPLANT_ID": "implant_id",
                        "LAST_CHECKIN": "last_checkin",
                        "METHOD": "method",
                        "ORG_ID": "org_id",
                        "SRC_IP": "src_ip",
                        "SRC_IP_STR": "src_ip_str"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_attack_implants_endpoint = _Endpoint(
            settings={
                'response_type': (AttackImplantsGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/attack/api/v1/user/implants',
                'operation_id': 'get_attack_implants',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-ARCH": "-arch",
                        "-BART_ID": "-bart_id",
                        "-BITS": "-bits",
                        "-CREATED_ON": "-created_on",
                        "-HOST_IPS": "-host_ips",
                        "-HOSTNAMES": "-hostnames",
                        "-ID": "-id",
                        "-LAST_CHECKIN": "-last_checkin",
                        "-METHOD": "-method",
                        "-NEXT_CHECKIN": "-next_checkin",
                        "-NICK": "-nick",
                        "-ORG_ID": "-org_id",
                        "-OS": "-os",
                        "-OSTYPE": "-ostype",
                        "-OSVER": "-osver",
                        "-STATUS": "-status",
                        "-UID": "-uid",
                        "ARCH": "arch",
                        "BART_ID": "bart_id",
                        "BITS": "bits",
                        "CREATED_ON": "created_on",
                        "HOST_IPS": "host_ips",
                        "HOSTNAMES": "hostnames",
                        "ID": "id",
                        "LAST_CHECKIN": "last_checkin",
                        "METHOD": "method",
                        "NEXT_CHECKIN": "next_checkin",
                        "NICK": "nick",
                        "ORG_ID": "org_id",
                        "OS": "os",
                        "OSTYPE": "ostype",
                        "OSVER": "osver",
                        "STATUS": "status",
                        "UID": "uid"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_attack_interfaces_for_implant_endpoint = _Endpoint(
            settings={
                'response_type': (AttackInterfacesForImplantGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/attack/api/v1/user/interfaces-for-implant',
                'operation_id': 'get_attack_interfaces_for_implant',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-ADDRESS": "-address",
                        "-BART_ID": "-bart_id",
                        "-ID": "-id",
                        "-IMPLANT_ID": "-implant_id",
                        "-IP_STRS": "-ip_strs",
                        "-NAME": "-name",
                        "-ORG_ID": "-org_id",
                        "ADDRESS": "address",
                        "BART_ID": "bart_id",
                        "ID": "id",
                        "IMPLANT_ID": "implant_id",
                        "IP_STRS": "ip_strs",
                        "NAME": "name",
                        "ORG_ID": "org_id"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_attack_redirectors_endpoint = _Endpoint(
            settings={
                'response_type': (AttackRedirectorsGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/attack/api/v1/user/redirectors',
                'operation_id': 'get_attack_redirectors',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-BART_ID": "-bart_id",
                        "-CREATED_ON": "-created_on",
                        "-DELETED": "-deleted",
                        "-EXTERNAL_IP": "-external_ip",
                        "-EXTERNAL_IP_STR": "-external_ip_str",
                        "-ID": "-id",
                        "-ORG_ID": "-org_id",
                        "-REMOTE_ROW_ID": "-remote_row_id",
                        "-RETIRED": "-retired",
                        "-STATUS": "-status",
                        "-UPDATED_ON": "-updated_on",
                        "-USAGE": "-usage",
                        "BART_ID": "bart_id",
                        "CREATED_ON": "created_on",
                        "DELETED": "deleted",
                        "EXTERNAL_IP": "external_ip",
                        "EXTERNAL_IP_STR": "external_ip_str",
                        "ID": "id",
                        "ORG_ID": "org_id",
                        "REMOTE_ROW_ID": "remote_row_id",
                        "RETIRED": "retired",
                        "STATUS": "status",
                        "UPDATED_ON": "updated_on",
                        "USAGE": "usage"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_attack_runbook_endpoint = _Endpoint(
            settings={
                'response_type': (AttackRunbookGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/attack/api/v1/user/runbooks',
                'operation_id': 'get_attack_runbook',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-COMMENT": "-comment",
                        "-DELETED": "-deleted",
                        "-DESCRIPTION": "-description",
                        "-DST_EMAIL": "-dst_email",
                        "-DST_HOST": "-dst_host",
                        "-DST_IP": "-dst_ip",
                        "-DST_MAC": "-dst_mac",
                        "-DST_MISC": "-dst_misc",
                        "-DST_NETWORK": "-dst_network",
                        "-DST_PATH": "-dst_path",
                        "-DST_PORT": "-dst_port",
                        "-DST_SEARCH": "-dst_search",
                        "-END_TIME": "-end_time",
                        "-GUIDANCE": "-guidance",
                        "-ID": "-id",
                        "-IMPLANT_IDS": "-implant_ids",
                        "-IMPLANT_NICK": "-implant_nick",
                        "-IMPLANT_SRC_HOST": "-implant_src_host",
                        "-IMPLANT_SRC_IP": "-implant_src_ip",
                        "-INSTANCE_LABEL": "-instance_label",
                        "-NAME": "-name",
                        "-OBJECTIVE": "-objective",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE_METADATA": "-perspective_metadata",
                        "-RANDORI_NOTES": "-randori_notes",
                        "-RESULTS": "-results",
                        "-RUNBOOK_ID": "-runbook_id",
                        "-SRC_EMAIL": "-src_email",
                        "-SRC_HOST": "-src_host",
                        "-SRC_IP": "-src_ip",
                        "-SRC_MAC": "-src_mac",
                        "-SRC_MISC": "-src_misc",
                        "-SRC_SEARCH": "-src_search",
                        "-START_TIME": "-start_time",
                        "-STATUS": "-status",
                        "-TECHNIQUE_IDS": "-technique_ids",
                        "-TRIGGER": "-trigger",
                        "-UID": "-uid",
                        "COMMENT": "comment",
                        "DELETED": "deleted",
                        "DESCRIPTION": "description",
                        "DST_EMAIL": "dst_email",
                        "DST_HOST": "dst_host",
                        "DST_IP": "dst_ip",
                        "DST_MAC": "dst_mac",
                        "DST_MISC": "dst_misc",
                        "DST_NETWORK": "dst_network",
                        "DST_PATH": "dst_path",
                        "DST_PORT": "dst_port",
                        "DST_SEARCH": "dst_search",
                        "END_TIME": "end_time",
                        "GUIDANCE": "guidance",
                        "ID": "id",
                        "IMPLANT_IDS": "implant_ids",
                        "IMPLANT_NICK": "implant_nick",
                        "IMPLANT_SRC_HOST": "implant_src_host",
                        "IMPLANT_SRC_IP": "implant_src_ip",
                        "INSTANCE_LABEL": "instance_label",
                        "NAME": "name",
                        "OBJECTIVE": "objective",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE_METADATA": "perspective_metadata",
                        "RANDORI_NOTES": "randori_notes",
                        "RESULTS": "results",
                        "RUNBOOK_ID": "runbook_id",
                        "SRC_EMAIL": "src_email",
                        "SRC_HOST": "src_host",
                        "SRC_IP": "src_ip",
                        "SRC_MAC": "src_mac",
                        "SRC_MISC": "src_misc",
                        "SRC_SEARCH": "src_search",
                        "START_TIME": "start_time",
                        "STATUS": "status",
                        "TECHNIQUE_IDS": "technique_ids",
                        "TRIGGER": "trigger",
                        "UID": "uid"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_attack_statistics_endpoint = _Endpoint(
            settings={
                'response_type': (AttackStatisticsGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/attack/api/v1/user/statistics',
                'operation_id': 'get_attack_statistics',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-CURRENT": "-current",
                        "-ID": "-id",
                        "-INDEX": "-index",
                        "-LATEST": "-latest",
                        "-NAME": "-name",
                        "-ORG_ID": "-org_id",
                        "-ROW_TIME": "-row_time",
                        "-TIME": "-time",
                        "-TYPE": "-type",
                        "-VALUE": "-value",
                        "CURRENT": "current",
                        "ID": "id",
                        "INDEX": "index",
                        "LATEST": "latest",
                        "NAME": "name",
                        "ORG_ID": "org_id",
                        "ROW_TIME": "row_time",
                        "TIME": "time",
                        "TYPE": "type",
                        "VALUE": "value"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_authorization_policy_endpoint = _Endpoint(
            settings={
                'response_type': (AuthorizationPolicyGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/authorization-policy',
                'operation_id': 'get_authorization_policy',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-ACTIONS": "-actions",
                        "-CREATED_AT": "-created_at",
                        "-EDITED_AT": "-edited_at",
                        "-ENTITY_TYPES": "-entity_types",
                        "-EXPIRES_AT": "-expires_at",
                        "-FILTER_DATA": "-filter_data",
                        "-ID": "-id",
                        "-IS_ACTIVE": "-is_active",
                        "-IS_DELETED": "-is_deleted",
                        "-IS_DIRTY": "-is_dirty",
                        "-NAME": "-name",
                        "-NOTES": "-notes",
                        "-ORG_ID": "-org_id",
                        "-VERSION": "-version",
                        "ACTIONS": "actions",
                        "CREATED_AT": "created_at",
                        "EDITED_AT": "edited_at",
                        "ENTITY_TYPES": "entity_types",
                        "EXPIRES_AT": "expires_at",
                        "FILTER_DATA": "filter_data",
                        "ID": "id",
                        "IS_ACTIVE": "is_active",
                        "IS_DELETED": "is_deleted",
                        "IS_DIRTY": "is_dirty",
                        "NAME": "name",
                        "NOTES": "notes",
                        "ORG_ID": "org_id",
                        "VERSION": "version"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_comment_endpoint = _Endpoint(
            settings={
                'response_type': (CommentResponseCollectionSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/entity/{entity_id}/comment',
                'operation_id': 'get_comment',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'entity_id',
                    'offset',
                    'limit',
                ],
                'required': [
                    'entity_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'entity_id':
                        (str,),
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                },
                'attribute_map': {
                    'entity_id': 'entity_id',
                    'offset': 'offset',
                    'limit': 'limit',
                },
                'location_map': {
                    'entity_id': 'path',
                    'offset': 'query',
                    'limit': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_guidance_file_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/guidance-articles/api/v1/{tag}.md',
                'operation_id': 'get_guidance_file',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'tag',
                ],
                'required': [
                    'tag',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'tag':
                        (str,),
                },
                'attribute_map': {
                    'tag': 'tag',
                },
                'location_map': {
                    'tag': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_hostname_endpoint = _Endpoint(
            settings={
                'response_type': (HostnameGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/hostname',
                'operation_id': 'get_hostname',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-AFFILIATION_STATE": "-affiliation_state",
                        "-AUTHORITY": "-authority",
                        "-AUTHORITY_DISTANCE": "-authority_distance",
                        "-AUTHORITY_OVERRIDE": "-authority_override",
                        "-CHARACTERISTIC_TAGS": "-characteristic_tags",
                        "-CONFIDENCE": "-confidence",
                        "-DELETED": "-deleted",
                        "-FIRST_SEEN": "-first_seen",
                        "-HOSTNAME": "-hostname",
                        "-ID": "-id",
                        "-IMPACT_SCORE": "-impact_score",
                        "-IP_COUNT": "-ip_count",
                        "-IPS": "-ips",
                        "-IS_PRIME": "-is_prime",
                        "-LAST_SEEN": "-last_seen",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-MAX_CONFIDENCE": "-max_confidence",
                        "-NAME_TYPE": "-name_type",
                        "-ONLY_IN_REVIEW_TARGETS": "-only_in_review_targets",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-PRIORITY_IMPACT_FACTOR": "-priority_impact_factor",
                        "-PRIORITY_SCORE": "-priority_score",
                        "-PRIORITY_STATUS_FACTOR": "-priority_status_factor",
                        "-PRIORITY_TAGS_FACTOR": "-priority_tags_factor",
                        "-STATUS": "-status",
                        "-TARGET_TEMPTATION": "-target_temptation",
                        "-USER_TAGS": "-user_tags",
                        "AFFILIATION_STATE": "affiliation_state",
                        "AUTHORITY": "authority",
                        "AUTHORITY_DISTANCE": "authority_distance",
                        "AUTHORITY_OVERRIDE": "authority_override",
                        "CHARACTERISTIC_TAGS": "characteristic_tags",
                        "CONFIDENCE": "confidence",
                        "DELETED": "deleted",
                        "FIRST_SEEN": "first_seen",
                        "HOSTNAME": "hostname",
                        "ID": "id",
                        "IMPACT_SCORE": "impact_score",
                        "IP_COUNT": "ip_count",
                        "IPS": "ips",
                        "IS_PRIME": "is_prime",
                        "LAST_SEEN": "last_seen",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "MAX_CONFIDENCE": "max_confidence",
                        "NAME_TYPE": "name_type",
                        "ONLY_IN_REVIEW_TARGETS": "only_in_review_targets",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "PRIORITY_IMPACT_FACTOR": "priority_impact_factor",
                        "PRIORITY_SCORE": "priority_score",
                        "PRIORITY_STATUS_FACTOR": "priority_status_factor",
                        "PRIORITY_TAGS_FACTOR": "priority_tags_factor",
                        "STATUS": "status",
                        "TARGET_TEMPTATION": "target_temptation",
                        "USER_TAGS": "user_tags"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_hostnames_for_ip_endpoint = _Endpoint(
            settings={
                'response_type': (HostnamesForIpGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/hostnames-for-ip',
                'operation_id': 'get_hostnames_for_ip',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-AFFILIATION_STATE": "-affiliation_state",
                        "-CONFIDENCE": "-confidence",
                        "-DELETED": "-deleted",
                        "-HOSTNAME": "-hostname",
                        "-HOSTNAME_ID": "-hostname_id",
                        "-ID": "-id",
                        "-IMPACT_SCORE": "-impact_score",
                        "-IP_ID": "-ip_id",
                        "-LAST_SEEN": "-last_seen",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-STATUS": "-status",
                        "AFFILIATION_STATE": "affiliation_state",
                        "CONFIDENCE": "confidence",
                        "DELETED": "deleted",
                        "HOSTNAME": "hostname",
                        "HOSTNAME_ID": "hostname_id",
                        "ID": "id",
                        "IMPACT_SCORE": "impact_score",
                        "IP_ID": "ip_id",
                        "LAST_SEEN": "last_seen",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "STATUS": "status"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_ip_endpoint = _Endpoint(
            settings={
                'response_type': (IpGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/ip',
                'operation_id': 'get_ip',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-AFFILIATION_STATE": "-affiliation_state",
                        "-ALL_PORTS": "-all_ports",
                        "-AUTHORITY": "-authority",
                        "-AUTHORITY_DISTANCE": "-authority_distance",
                        "-AUTHORITY_OVERRIDE": "-authority_override",
                        "-CHARACTERISTIC_TAGS": "-characteristic_tags",
                        "-CONFIDENCE": "-confidence",
                        "-COUNTRY": "-country",
                        "-DELETED": "-deleted",
                        "-FIRST_SEEN": "-first_seen",
                        "-HOSTNAME_COUNT": "-hostname_count",
                        "-HOSTNAMES": "-hostnames",
                        "-ID": "-id",
                        "-IMPACT_SCORE": "-impact_score",
                        "-IP": "-ip",
                        "-IP_STR": "-ip_str",
                        "-LAST_SEEN": "-last_seen",
                        "-LATITUDE": "-latitude",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-LONGITUDE": "-longitude",
                        "-ONLY_IN_REVIEW_TARGETS": "-only_in_review_targets",
                        "-OPEN_PORT_COUNT": "-open_port_count",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-PRIORITY_IMPACT_FACTOR": "-priority_impact_factor",
                        "-PRIORITY_SCORE": "-priority_score",
                        "-PRIORITY_STATUS_FACTOR": "-priority_status_factor",
                        "-PRIORITY_TAGS_FACTOR": "-priority_tags_factor",
                        "-RADIUS": "-radius",
                        "-SERVICE_COUNT": "-service_count",
                        "-STATUS": "-status",
                        "-TARGET_COUNT": "-target_count",
                        "-TARGET_TEMPTATION": "-target_temptation",
                        "-USER_TAGS": "-user_tags",
                        "AFFILIATION_STATE": "affiliation_state",
                        "ALL_PORTS": "all_ports",
                        "AUTHORITY": "authority",
                        "AUTHORITY_DISTANCE": "authority_distance",
                        "AUTHORITY_OVERRIDE": "authority_override",
                        "CHARACTERISTIC_TAGS": "characteristic_tags",
                        "CONFIDENCE": "confidence",
                        "COUNTRY": "country",
                        "DELETED": "deleted",
                        "FIRST_SEEN": "first_seen",
                        "HOSTNAME_COUNT": "hostname_count",
                        "HOSTNAMES": "hostnames",
                        "ID": "id",
                        "IMPACT_SCORE": "impact_score",
                        "IP": "ip",
                        "IP_STR": "ip_str",
                        "LAST_SEEN": "last_seen",
                        "LATITUDE": "latitude",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "LONGITUDE": "longitude",
                        "ONLY_IN_REVIEW_TARGETS": "only_in_review_targets",
                        "OPEN_PORT_COUNT": "open_port_count",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "PRIORITY_IMPACT_FACTOR": "priority_impact_factor",
                        "PRIORITY_SCORE": "priority_score",
                        "PRIORITY_STATUS_FACTOR": "priority_status_factor",
                        "PRIORITY_TAGS_FACTOR": "priority_tags_factor",
                        "RADIUS": "radius",
                        "SERVICE_COUNT": "service_count",
                        "STATUS": "status",
                        "TARGET_COUNT": "target_count",
                        "TARGET_TEMPTATION": "target_temptation",
                        "USER_TAGS": "user_tags"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_ips_for_hostname_endpoint = _Endpoint(
            settings={
                'response_type': (IpsForHostnameGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/ips-for-hostname',
                'operation_id': 'get_ips_for_hostname',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-AFFILIATION_STATE": "-affiliation_state",
                        "-CONFIDENCE": "-confidence",
                        "-COUNTRY": "-country",
                        "-DELETED": "-deleted",
                        "-HOSTNAME_ID": "-hostname_id",
                        "-ID": "-id",
                        "-IMPACT_SCORE": "-impact_score",
                        "-IP": "-ip",
                        "-IP_ID": "-ip_id",
                        "-IP_STR": "-ip_str",
                        "-LAST_SEEN": "-last_seen",
                        "-LATITUDE": "-latitude",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-LONGITUDE": "-longitude",
                        "-OPEN_PORT_COUNT": "-open_port_count",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-RADIUS": "-radius",
                        "-SERVICE_COUNT": "-service_count",
                        "-STATUS": "-status",
                        "-TARGET_COUNT": "-target_count",
                        "-TARGET_TEMPTATION": "-target_temptation",
                        "-TOP_HOSTNAME": "-top_hostname",
                        "AFFILIATION_STATE": "affiliation_state",
                        "CONFIDENCE": "confidence",
                        "COUNTRY": "country",
                        "DELETED": "deleted",
                        "HOSTNAME_ID": "hostname_id",
                        "ID": "id",
                        "IMPACT_SCORE": "impact_score",
                        "IP": "ip",
                        "IP_ID": "ip_id",
                        "IP_STR": "ip_str",
                        "LAST_SEEN": "last_seen",
                        "LATITUDE": "latitude",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "LONGITUDE": "longitude",
                        "OPEN_PORT_COUNT": "open_port_count",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "RADIUS": "radius",
                        "SERVICE_COUNT": "service_count",
                        "STATUS": "status",
                        "TARGET_COUNT": "target_count",
                        "TARGET_TEMPTATION": "target_temptation",
                        "TOP_HOSTNAME": "top_hostname"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_ips_for_network_endpoint = _Endpoint(
            settings={
                'response_type': (IpsForNetworkGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/ips-for-network',
                'operation_id': 'get_ips_for_network',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-AFFILIATION_STATE": "-affiliation_state",
                        "-CHARACTERISTIC_TAGS": "-characteristic_tags",
                        "-CONFIDENCE": "-confidence",
                        "-COUNTRY": "-country",
                        "-DELETED": "-deleted",
                        "-HOSTNAME": "-hostname",
                        "-ID": "-id",
                        "-IMPACT_SCORE": "-impact_score",
                        "-IP": "-ip",
                        "-IP_ID": "-ip_id",
                        "-IP_STR": "-ip_str",
                        "-LAST_SEEN": "-last_seen",
                        "-LATITUDE": "-latitude",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-LONGITUDE": "-longitude",
                        "-NETWORK": "-network",
                        "-NETWORK_ID": "-network_id",
                        "-NETWORK_STR": "-network_str",
                        "-OPEN_PORT_COUNT": "-open_port_count",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-RADIUS": "-radius",
                        "-SERVICE_COUNT": "-service_count",
                        "-STATUS": "-status",
                        "-TARGET_COUNT": "-target_count",
                        "-TARGET_TEMPTATION": "-target_temptation",
                        "-USER_TAGS": "-user_tags",
                        "AFFILIATION_STATE": "affiliation_state",
                        "CHARACTERISTIC_TAGS": "characteristic_tags",
                        "CONFIDENCE": "confidence",
                        "COUNTRY": "country",
                        "DELETED": "deleted",
                        "HOSTNAME": "hostname",
                        "ID": "id",
                        "IMPACT_SCORE": "impact_score",
                        "IP": "ip",
                        "IP_ID": "ip_id",
                        "IP_STR": "ip_str",
                        "LAST_SEEN": "last_seen",
                        "LATITUDE": "latitude",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "LONGITUDE": "longitude",
                        "NETWORK": "network",
                        "NETWORK_ID": "network_id",
                        "NETWORK_STR": "network_str",
                        "OPEN_PORT_COUNT": "open_port_count",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "RADIUS": "radius",
                        "SERVICE_COUNT": "service_count",
                        "STATUS": "status",
                        "TARGET_COUNT": "target_count",
                        "TARGET_TEMPTATION": "target_temptation",
                        "USER_TAGS": "user_tags"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_ips_for_service_endpoint = _Endpoint(
            settings={
                'response_type': (IpsForServiceGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/ips-for-service',
                'operation_id': 'get_ips_for_service',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-AFFILIATION_STATE": "-affiliation_state",
                        "-CONFIDENCE": "-confidence",
                        "-COUNTRY": "-country",
                        "-DELETED": "-deleted",
                        "-FIRST_SEEN": "-first_seen",
                        "-ID": "-id",
                        "-IMPACT_SCORE": "-impact_score",
                        "-IP": "-ip",
                        "-IP_ID": "-ip_id",
                        "-IP_STR": "-ip_str",
                        "-LAST_SEEN": "-last_seen",
                        "-LATITUDE": "-latitude",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-LONGITUDE": "-longitude",
                        "-OPEN_PORT_COUNT": "-open_port_count",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-RADIUS": "-radius",
                        "-SERVICE_COUNT": "-service_count",
                        "-SERVICE_ID": "-service_id",
                        "-STATUS": "-status",
                        "-TARGET_COUNT": "-target_count",
                        "-TARGET_TEMPTATION": "-target_temptation",
                        "AFFILIATION_STATE": "affiliation_state",
                        "CONFIDENCE": "confidence",
                        "COUNTRY": "country",
                        "DELETED": "deleted",
                        "FIRST_SEEN": "first_seen",
                        "ID": "id",
                        "IMPACT_SCORE": "impact_score",
                        "IP": "ip",
                        "IP_ID": "ip_id",
                        "IP_STR": "ip_str",
                        "LAST_SEEN": "last_seen",
                        "LATITUDE": "latitude",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "LONGITUDE": "longitude",
                        "OPEN_PORT_COUNT": "open_port_count",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "RADIUS": "radius",
                        "SERVICE_COUNT": "service_count",
                        "SERVICE_ID": "service_id",
                        "STATUS": "status",
                        "TARGET_COUNT": "target_count",
                        "TARGET_TEMPTATION": "target_temptation"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_network_endpoint = _Endpoint(
            settings={
                'response_type': (NetworkGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/network',
                'operation_id': 'get_network',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-AFFILIATION_STATE": "-affiliation_state",
                        "-AUTHORITY": "-authority",
                        "-AUTHORITY_DISTANCE": "-authority_distance",
                        "-AUTHORITY_OVERRIDE": "-authority_override",
                        "-CHARACTERISTIC_TAGS": "-characteristic_tags",
                        "-CONFIDENCE": "-confidence",
                        "-DELETED": "-deleted",
                        "-FIRST_SEEN": "-first_seen",
                        "-ID": "-id",
                        "-IMPACT_SCORE": "-impact_score",
                        "-IP_COUNT": "-ip_count",
                        "-LAST_SEEN": "-last_seen",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-MAX_CONFIDENCE": "-max_confidence",
                        "-NETWORK": "-network",
                        "-NETWORK_STR": "-network_str",
                        "-ONLY_IN_REVIEW_TARGETS": "-only_in_review_targets",
                        "-OPEN_PORT_COUNT": "-open_port_count",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-PRIORITY_IMPACT_FACTOR": "-priority_impact_factor",
                        "-PRIORITY_SCORE": "-priority_score",
                        "-PRIORITY_STATUS_FACTOR": "-priority_status_factor",
                        "-PRIORITY_TAGS_FACTOR": "-priority_tags_factor",
                        "-SERVICE_COUNT": "-service_count",
                        "-STATUS": "-status",
                        "-TARGET_COUNT": "-target_count",
                        "-TARGET_TEMPTATION": "-target_temptation",
                        "-USER_TAGS": "-user_tags",
                        "AFFILIATION_STATE": "affiliation_state",
                        "AUTHORITY": "authority",
                        "AUTHORITY_DISTANCE": "authority_distance",
                        "AUTHORITY_OVERRIDE": "authority_override",
                        "CHARACTERISTIC_TAGS": "characteristic_tags",
                        "CONFIDENCE": "confidence",
                        "DELETED": "deleted",
                        "FIRST_SEEN": "first_seen",
                        "ID": "id",
                        "IMPACT_SCORE": "impact_score",
                        "IP_COUNT": "ip_count",
                        "LAST_SEEN": "last_seen",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "MAX_CONFIDENCE": "max_confidence",
                        "NETWORK": "network",
                        "NETWORK_STR": "network_str",
                        "ONLY_IN_REVIEW_TARGETS": "only_in_review_targets",
                        "OPEN_PORT_COUNT": "open_port_count",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "PRIORITY_IMPACT_FACTOR": "priority_impact_factor",
                        "PRIORITY_SCORE": "priority_score",
                        "PRIORITY_STATUS_FACTOR": "priority_status_factor",
                        "PRIORITY_TAGS_FACTOR": "priority_tags_factor",
                        "SERVICE_COUNT": "service_count",
                        "STATUS": "status",
                        "TARGET_COUNT": "target_count",
                        "TARGET_TEMPTATION": "target_temptation",
                        "USER_TAGS": "user_tags"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_organization_endpoint = _Endpoint(
            settings={
                'response_type': (OrganizationGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/organization',
                'operation_id': 'get_organization',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-ADDRESS": "-address",
                        "-ALLOWED_EMAIL_DOMAINS": "-allowed_email_domains",
                        "-CONTACT": "-contact",
                        "-CREATED_ON": "-created_on",
                        "-ID": "-id",
                        "-LICENSE_LEVEL": "-license_level",
                        "-LOGIN_METHODS": "-login_methods",
                        "-NAME": "-name",
                        "-PAYING": "-paying",
                        "-PLATFORM_SUBSCRIPTION_ID": "-platform_subscription_id",
                        "-SHORTNAME": "-shortname",
                        "-SSO_PATH": "-sso_path",
                        "-STASIS": "-stasis",
                        "-STASIS_LAST_UPDATE_BY": "-stasis_last_update_by",
                        "-STASIS_LAST_UPDATE_ON": "-stasis_last_update_on",
                        "ADDRESS": "address",
                        "ALLOWED_EMAIL_DOMAINS": "allowed_email_domains",
                        "CONTACT": "contact",
                        "CREATED_ON": "created_on",
                        "ID": "id",
                        "LICENSE_LEVEL": "license_level",
                        "LOGIN_METHODS": "login_methods",
                        "NAME": "name",
                        "PAYING": "paying",
                        "PLATFORM_SUBSCRIPTION_ID": "platform_subscription_id",
                        "SHORTNAME": "shortname",
                        "SSO_PATH": "sso_path",
                        "STASIS": "stasis",
                        "STASIS_LAST_UPDATE_BY": "stasis_last_update_by",
                        "STASIS_LAST_UPDATE_ON": "stasis_last_update_on"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_policy_endpoint = _Endpoint(
            settings={
                'response_type': (PolicyGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/policy',
                'operation_id': 'get_policy',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-ACTIONS": "-actions",
                        "-CREATED_AT": "-created_at",
                        "-EDITED_AT": "-edited_at",
                        "-ENTITY_TYPES": "-entity_types",
                        "-EXPIRES_AT": "-expires_at",
                        "-FILTER_DATA": "-filter_data",
                        "-ID": "-id",
                        "-IS_ACTIVE": "-is_active",
                        "-IS_DELETED": "-is_deleted",
                        "-IS_DIRTY": "-is_dirty",
                        "-NAME": "-name",
                        "-NOTES": "-notes",
                        "-ORG_ID": "-org_id",
                        "-VERSION": "-version",
                        "ACTIONS": "actions",
                        "CREATED_AT": "created_at",
                        "EDITED_AT": "edited_at",
                        "ENTITY_TYPES": "entity_types",
                        "EXPIRES_AT": "expires_at",
                        "FILTER_DATA": "filter_data",
                        "ID": "id",
                        "IS_ACTIVE": "is_active",
                        "IS_DELETED": "is_deleted",
                        "IS_DIRTY": "is_dirty",
                        "NAME": "name",
                        "NOTES": "notes",
                        "ORG_ID": "org_id",
                        "VERSION": "version"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_ports_for_ip_endpoint = _Endpoint(
            settings={
                'response_type': (PortsForIpGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/ports-for-ip',
                'operation_id': 'get_ports_for_ip',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-CONFIDENCE": "-confidence",
                        "-DELETED": "-deleted",
                        "-ID": "-id",
                        "-IP_ID": "-ip_id",
                        "-LAST_SEEN": "-last_seen",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-PORT": "-port",
                        "-PROTOCOL": "-protocol",
                        "-SEEN_OPEN": "-seen_open",
                        "-STATE": "-state",
                        "CONFIDENCE": "confidence",
                        "DELETED": "deleted",
                        "ID": "id",
                        "IP_ID": "ip_id",
                        "LAST_SEEN": "last_seen",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "PORT": "port",
                        "PROTOCOL": "protocol",
                        "SEEN_OPEN": "seen_open",
                        "STATE": "state"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_preferences_endpoint = _Endpoint(
            settings={
                'response_type': (PreferenceOutCollection,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/preferences',
                'operation_id': 'get_preferences',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'names',
                    'group_names',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'names':
                        ([str],),
                    'group_names':
                        ([str],),
                },
                'attribute_map': {
                    'names': 'names',
                    'group_names': 'group_names',
                },
                'location_map': {
                    'names': 'query',
                    'group_names': 'query',
                },
                'collection_format_map': {
                    'names': 'multi',
                    'group_names': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_saved_views_endpoint = _Endpoint(
            settings={
                'response_type': (SavedViewsGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/saved-views',
                'operation_id': 'get_saved_views',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-CREATED_AT": "-created_at",
                        "-DESCRIPTION": "-description",
                        "-EDITED_AT": "-edited_at",
                        "-ENTITY_TYPE": "-entity_type",
                        "-FILTER_DATA": "-filter_data",
                        "-ID": "-id",
                        "-IS_FAVORITE": "-is_favorite",
                        "-IS_GLOBAL": "-is_global",
                        "-NAME": "-name",
                        "-ORG_ID": "-org_id",
                        "-SORT_DATA": "-sort_data",
                        "CREATED_AT": "created_at",
                        "DESCRIPTION": "description",
                        "EDITED_AT": "edited_at",
                        "ENTITY_TYPE": "entity_type",
                        "FILTER_DATA": "filter_data",
                        "ID": "id",
                        "IS_FAVORITE": "is_favorite",
                        "IS_GLOBAL": "is_global",
                        "NAME": "name",
                        "ORG_ID": "org_id",
                        "SORT_DATA": "sort_data"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_service_endpoint = _Endpoint(
            settings={
                'response_type': (ServiceGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/service',
                'operation_id': 'get_service',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-APPLICABILITY": "-applicability",
                        "-ATTACK_NOTE": "-attack_note",
                        "-CONFIDENCE": "-confidence",
                        "-CPE": "-cpe",
                        "-CRITICALITY": "-criticality",
                        "-DELETED": "-deleted",
                        "-DESCRIPTION": "-description",
                        "-DESCRIPTION_SOURCE": "-description_source",
                        "-ENUMERABILITY": "-enumerability",
                        "-EXPLOITABILITY": "-exploitability",
                        "-FIRST_SEEN": "-first_seen",
                        "-ID": "-id",
                        "-INSTANCE_COUNT": "-instance_count",
                        "-IP_COUNT": "-ip_count",
                        "-LAST_SEEN": "-last_seen",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-NAME": "-name",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-POST_EXPLOIT": "-post_exploit",
                        "-PRIVATE_WEAKNESS": "-private_weakness",
                        "-PUBLIC_WEAKNESS": "-public_weakness",
                        "-RANDORI_NOTES": "-randori_notes",
                        "-REFERENCE": "-reference",
                        "-RESEARCH": "-research",
                        "-SERVICE_ID": "-service_id",
                        "-TARGET_TEMPTATION": "-target_temptation",
                        "-TECH_CATEGORY": "-tech_category",
                        "-TEMPTATION_LAST_MODIFIED": "-temptation_last_modified",
                        "-VENDOR": "-vendor",
                        "-VERSION": "-version",
                        "APPLICABILITY": "applicability",
                        "ATTACK_NOTE": "attack_note",
                        "CONFIDENCE": "confidence",
                        "CPE": "cpe",
                        "CRITICALITY": "criticality",
                        "DELETED": "deleted",
                        "DESCRIPTION": "description",
                        "DESCRIPTION_SOURCE": "description_source",
                        "ENUMERABILITY": "enumerability",
                        "EXPLOITABILITY": "exploitability",
                        "FIRST_SEEN": "first_seen",
                        "ID": "id",
                        "INSTANCE_COUNT": "instance_count",
                        "IP_COUNT": "ip_count",
                        "LAST_SEEN": "last_seen",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "NAME": "name",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "POST_EXPLOIT": "post_exploit",
                        "PRIVATE_WEAKNESS": "private_weakness",
                        "PUBLIC_WEAKNESS": "public_weakness",
                        "RANDORI_NOTES": "randori_notes",
                        "REFERENCE": "reference",
                        "RESEARCH": "research",
                        "SERVICE_ID": "service_id",
                        "TARGET_TEMPTATION": "target_temptation",
                        "TECH_CATEGORY": "tech_category",
                        "TEMPTATION_LAST_MODIFIED": "temptation_last_modified",
                        "VENDOR": "vendor",
                        "VERSION": "version"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_action_metadata_endpoint = _Endpoint(
            settings={
                'response_type': (ActionMetadataSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/attack/api/v1/user/actions/{id}',
                'operation_id': 'get_single_action_metadata',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_activity_log_endpoint = _Endpoint(
            settings={
                'response_type': (ActivityLogSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/activity-log/{id}',
                'operation_id': 'get_single_activity_log',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_attack_implants_endpoint = _Endpoint(
            settings={
                'response_type': (AttackImplantsSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/attack/api/v1/user/implants/{id}',
                'operation_id': 'get_single_attack_implants',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_detection_for_target_endpoint = _Endpoint(
            settings={
                'response_type': (SingleDetectionForTargetGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/single-detection-for-target',
                'operation_id': 'get_single_detection_for_target',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-AFFILIATION_STATE": "-affiliation_state",
                        "-APPLICABILITY": "-applicability",
                        "-ATTACK_NOTE": "-attack_note",
                        "-AUTHORITY": "-authority",
                        "-AUTHORITY_DISTANCE": "-authority_distance",
                        "-AUTHORITY_OVERRIDE": "-authority_override",
                        "-AUTHORIZATION_STATE": "-authorization_state",
                        "-AUTHORIZING_POLICIES": "-authorizing_policies",
                        "-BANNERS_UUID": "-banners_uuid",
                        "-CERT_UUID": "-cert_uuid",
                        "-CHARACTERISTIC_TAGS": "-characteristic_tags",
                        "-CHARACTERISTICS_COUNT": "-characteristics_count",
                        "-CONFIDENCE": "-confidence",
                        "-CPE": "-cpe",
                        "-CRITICALITY": "-criticality",
                        "-DELETED": "-deleted",
                        "-DESCRIPTION": "-description",
                        "-DESCRIPTION_SOURCE": "-description_source",
                        "-DETECTION_AUTHORIZATION_STATE": "-detection_authorization_state",
                        "-DETECTION_CRITERIA": "-detection_criteria",
                        "-DETECTION_RELEVANCE": "-detection_relevance",
                        "-DETECTION_UUID": "-detection_uuid",
                        "-ENUMERABILITY": "-enumerability",
                        "-EXPLOITABILITY": "-exploitability",
                        "-FIRST_SEEN": "-first_seen",
                        "-HEADERS_UUID": "-headers_uuid",
                        "-HOSTNAME": "-hostname",
                        "-HOSTNAME_ID": "-hostname_id",
                        "-ID": "-id",
                        "-IMPACT_SCORE": "-impact_score",
                        "-IP": "-ip",
                        "-IP_ID": "-ip_id",
                        "-IP_STR": "-ip_str",
                        "-LAST_SEEN": "-last_seen",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-NAME": "-name",
                        "-ORG_ID": "-org_id",
                        "-PATH": "-path",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-POC_EMAIL": "-poc_email",
                        "-POC_ID": "-poc_id",
                        "-PORT": "-port",
                        "-POST_EXPLOIT": "-post_exploit",
                        "-PRIORITY_IMPACT_FACTOR": "-priority_impact_factor",
                        "-PRIORITY_SCORE": "-priority_score",
                        "-PRIORITY_STATUS_FACTOR": "-priority_status_factor",
                        "-PRIORITY_TAGS_FACTOR": "-priority_tags_factor",
                        "-PRIVATE_WEAKNESS": "-private_weakness",
                        "-PROTOCOL": "-protocol",
                        "-PUBLIC_WEAKNESS": "-public_weakness",
                        "-RANDORI_NOTES": "-randori_notes",
                        "-REFERENCE": "-reference",
                        "-RESEARCH": "-research",
                        "-SCREENSHOT_UUID": "-screenshot_uuid",
                        "-SERVICE_ID": "-service_id",
                        "-STATUS": "-status",
                        "-TARGET_CONFIDENCE": "-target_confidence",
                        "-TARGET_FIRST_SEEN": "-target_first_seen",
                        "-TARGET_ID": "-target_id",
                        "-TARGET_LAST_SEEN": "-target_last_seen",
                        "-TARGET_NUM_AUTHORIZED_DETECTIONS": "-target_num_authorized_detections",
                        "-TARGET_NUM_DETECTIONS": "-target_num_detections",
                        "-TARGET_TEMPTATION": "-target_temptation",
                        "-TECH_CATEGORY": "-tech_category",
                        "-TEMPTATION_LAST_MODIFIED": "-temptation_last_modified",
                        "-THUMBNAIL_UUID": "-thumbnail_uuid",
                        "-USER_TAGS": "-user_tags",
                        "-VALIDATED_VULNERABILITIES_DETECTION": "-validated_vulnerabilities_detection",
                        "-VALIDATED_VULNERABILITIES_DETECTION_COUNT": "-validated_vulnerabilities_detection_count",
                        "-VALIDATED_VULNERABILITIES_TARGET": "-validated_vulnerabilities_target",
                        "-VALIDATED_VULNERABILITIES_TARGET_COUNT": "-validated_vulnerabilities_target_count",
                        "-VENDOR": "-vendor",
                        "-VERSION": "-version",
                        "AFFILIATION_STATE": "affiliation_state",
                        "APPLICABILITY": "applicability",
                        "ATTACK_NOTE": "attack_note",
                        "AUTHORITY": "authority",
                        "AUTHORITY_DISTANCE": "authority_distance",
                        "AUTHORITY_OVERRIDE": "authority_override",
                        "AUTHORIZATION_STATE": "authorization_state",
                        "AUTHORIZING_POLICIES": "authorizing_policies",
                        "BANNERS_UUID": "banners_uuid",
                        "CERT_UUID": "cert_uuid",
                        "CHARACTERISTIC_TAGS": "characteristic_tags",
                        "CHARACTERISTICS_COUNT": "characteristics_count",
                        "CONFIDENCE": "confidence",
                        "CPE": "cpe",
                        "CRITICALITY": "criticality",
                        "DELETED": "deleted",
                        "DESCRIPTION": "description",
                        "DESCRIPTION_SOURCE": "description_source",
                        "DETECTION_AUTHORIZATION_STATE": "detection_authorization_state",
                        "DETECTION_CRITERIA": "detection_criteria",
                        "DETECTION_RELEVANCE": "detection_relevance",
                        "DETECTION_UUID": "detection_uuid",
                        "ENUMERABILITY": "enumerability",
                        "EXPLOITABILITY": "exploitability",
                        "FIRST_SEEN": "first_seen",
                        "HEADERS_UUID": "headers_uuid",
                        "HOSTNAME": "hostname",
                        "HOSTNAME_ID": "hostname_id",
                        "ID": "id",
                        "IMPACT_SCORE": "impact_score",
                        "IP": "ip",
                        "IP_ID": "ip_id",
                        "IP_STR": "ip_str",
                        "LAST_SEEN": "last_seen",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "NAME": "name",
                        "ORG_ID": "org_id",
                        "PATH": "path",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "POC_EMAIL": "poc_email",
                        "POC_ID": "poc_id",
                        "PORT": "port",
                        "POST_EXPLOIT": "post_exploit",
                        "PRIORITY_IMPACT_FACTOR": "priority_impact_factor",
                        "PRIORITY_SCORE": "priority_score",
                        "PRIORITY_STATUS_FACTOR": "priority_status_factor",
                        "PRIORITY_TAGS_FACTOR": "priority_tags_factor",
                        "PRIVATE_WEAKNESS": "private_weakness",
                        "PROTOCOL": "protocol",
                        "PUBLIC_WEAKNESS": "public_weakness",
                        "RANDORI_NOTES": "randori_notes",
                        "REFERENCE": "reference",
                        "RESEARCH": "research",
                        "SCREENSHOT_UUID": "screenshot_uuid",
                        "SERVICE_ID": "service_id",
                        "STATUS": "status",
                        "TARGET_CONFIDENCE": "target_confidence",
                        "TARGET_FIRST_SEEN": "target_first_seen",
                        "TARGET_ID": "target_id",
                        "TARGET_LAST_SEEN": "target_last_seen",
                        "TARGET_NUM_AUTHORIZED_DETECTIONS": "target_num_authorized_detections",
                        "TARGET_NUM_DETECTIONS": "target_num_detections",
                        "TARGET_TEMPTATION": "target_temptation",
                        "TECH_CATEGORY": "tech_category",
                        "TEMPTATION_LAST_MODIFIED": "temptation_last_modified",
                        "THUMBNAIL_UUID": "thumbnail_uuid",
                        "USER_TAGS": "user_tags",
                        "VALIDATED_VULNERABILITIES_DETECTION": "validated_vulnerabilities_detection",
                        "VALIDATED_VULNERABILITIES_DETECTION_COUNT": "validated_vulnerabilities_detection_count",
                        "VALIDATED_VULNERABILITIES_TARGET": "validated_vulnerabilities_target",
                        "VALIDATED_VULNERABILITIES_TARGET_COUNT": "validated_vulnerabilities_target_count",
                        "VENDOR": "vendor",
                        "VERSION": "version"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_hostname_endpoint = _Endpoint(
            settings={
                'response_type': (HostnameSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/hostname/{id}',
                'operation_id': 'get_single_hostname',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_hostnames_for_ip_endpoint = _Endpoint(
            settings={
                'response_type': (HostnamesForIpSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/hostnames-for-ip/{id}',
                'operation_id': 'get_single_hostnames_for_ip',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_ip_endpoint = _Endpoint(
            settings={
                'response_type': (IpSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/ip/{id}',
                'operation_id': 'get_single_ip',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_ips_for_hostname_endpoint = _Endpoint(
            settings={
                'response_type': (IpsForHostnameSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/ips-for-hostname/{id}',
                'operation_id': 'get_single_ips_for_hostname',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_ips_for_network_endpoint = _Endpoint(
            settings={
                'response_type': (IpsForNetworkSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/ips-for-network/{id}',
                'operation_id': 'get_single_ips_for_network',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_ips_for_service_endpoint = _Endpoint(
            settings={
                'response_type': (IpsForServiceSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/ips-for-service/{id}',
                'operation_id': 'get_single_ips_for_service',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_network_endpoint = _Endpoint(
            settings={
                'response_type': (NetworkSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/network/{id}',
                'operation_id': 'get_single_network',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_organization_endpoint = _Endpoint(
            settings={
                'response_type': (OrganizationSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/organization/{id}',
                'operation_id': 'get_single_organization',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                },
                'location_map': {
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_ports_for_ip_endpoint = _Endpoint(
            settings={
                'response_type': (PortsForIpSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/ports-for-ip/{id}',
                'operation_id': 'get_single_ports_for_ip',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_saved_views_endpoint = _Endpoint(
            settings={
                'response_type': (SavedViewsSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/saved-views/{id}',
                'operation_id': 'get_single_saved_views',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_service_endpoint = _Endpoint(
            settings={
                'response_type': (ServiceSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/service/{id}',
                'operation_id': 'get_single_service',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_tagcounts_endpoint = _Endpoint(
            settings={
                'response_type': (TagcountsSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/tagcounts/{id}',
                'operation_id': 'get_single_tagcounts',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_target_endpoint = _Endpoint(
            settings={
                'response_type': (TargetSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/target/{id}',
                'operation_id': 'get_single_target',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'org_id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                    'org_id': 'org_id',
                },
                'location_map': {
                    'id': 'path',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_single_user_endpoint = _Endpoint(
            settings={
                'response_type': (UserSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/user/{id}',
                'operation_id': 'get_single_user',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                },
                'location_map': {
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_social_entity_endpoint = _Endpoint(
            settings={
                'response_type': (SocialEntityGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/social-entity',
                'operation_id': 'get_social_entity',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-ADDRESS": "-address",
                        "-AFFILIATION_STATE": "-affiliation_state",
                        "-AUTHORITY": "-authority",
                        "-AUTHORITY_DISTANCE": "-authority_distance",
                        "-AUTHORITY_OVERRIDE": "-authority_override",
                        "-AUTHORIZATION_STATE": "-authorization_state",
                        "-CHARACTERISTIC_TAGS": "-characteristic_tags",
                        "-CITY": "-city",
                        "-COMPANY_NAME": "-company_name",
                        "-CONFIDENCE": "-confidence",
                        "-COUNTRY": "-country",
                        "-DELETED": "-deleted",
                        "-DETAILS": "-details",
                        "-DOMAIN": "-domain",
                        "-EMAIL": "-email",
                        "-EMAIL_TYPE": "-email_type",
                        "-FIRST_SEEN": "-first_seen",
                        "-ID": "-id",
                        "-IMPACT_SCORE": "-impact_score",
                        "-LAST_SEEN": "-last_seen",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-ONLY_IN_REVIEW_TARGETS": "-only_in_review_targets",
                        "-ORG_ID": "-org_id",
                        "-PERSON_FIRST_NAME": "-person_first_name",
                        "-PERSON_LAST_NAME": "-person_last_name",
                        "-PERSON_MIDDLE_NAME": "-person_middle_name",
                        "-PERSON_NAME": "-person_name",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-PHONE": "-phone",
                        "-POSTAL_CODE": "-postal_code",
                        "-PRIORITY_IMPACT_FACTOR": "-priority_impact_factor",
                        "-PRIORITY_SCORE": "-priority_score",
                        "-PRIORITY_STATUS_FACTOR": "-priority_status_factor",
                        "-PRIORITY_TAGS_FACTOR": "-priority_tags_factor",
                        "-ROLE": "-role",
                        "-SENIORITY": "-seniority",
                        "-STATE": "-state",
                        "-STATUS": "-status",
                        "-SUB_ROLE": "-sub_role",
                        "-TARGET_TEMPTATION": "-target_temptation",
                        "-TITLE": "-title",
                        "-TLD": "-tld",
                        "-USER_TAGS": "-user_tags",
                        "-USERNAME": "-username",
                        "ADDRESS": "address",
                        "AFFILIATION_STATE": "affiliation_state",
                        "AUTHORITY": "authority",
                        "AUTHORITY_DISTANCE": "authority_distance",
                        "AUTHORITY_OVERRIDE": "authority_override",
                        "AUTHORIZATION_STATE": "authorization_state",
                        "CHARACTERISTIC_TAGS": "characteristic_tags",
                        "CITY": "city",
                        "COMPANY_NAME": "company_name",
                        "CONFIDENCE": "confidence",
                        "COUNTRY": "country",
                        "DELETED": "deleted",
                        "DETAILS": "details",
                        "DOMAIN": "domain",
                        "EMAIL": "email",
                        "EMAIL_TYPE": "email_type",
                        "FIRST_SEEN": "first_seen",
                        "ID": "id",
                        "IMPACT_SCORE": "impact_score",
                        "LAST_SEEN": "last_seen",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "ONLY_IN_REVIEW_TARGETS": "only_in_review_targets",
                        "ORG_ID": "org_id",
                        "PERSON_FIRST_NAME": "person_first_name",
                        "PERSON_LAST_NAME": "person_last_name",
                        "PERSON_MIDDLE_NAME": "person_middle_name",
                        "PERSON_NAME": "person_name",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "PHONE": "phone",
                        "POSTAL_CODE": "postal_code",
                        "PRIORITY_IMPACT_FACTOR": "priority_impact_factor",
                        "PRIORITY_SCORE": "priority_score",
                        "PRIORITY_STATUS_FACTOR": "priority_status_factor",
                        "PRIORITY_TAGS_FACTOR": "priority_tags_factor",
                        "ROLE": "role",
                        "SENIORITY": "seniority",
                        "STATE": "state",
                        "STATUS": "status",
                        "SUB_ROLE": "sub_role",
                        "TARGET_TEMPTATION": "target_temptation",
                        "TITLE": "title",
                        "TLD": "tld",
                        "USER_TAGS": "user_tags",
                        "USERNAME": "username"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_statistics_endpoint = _Endpoint(
            settings={
                'response_type': (StatisticsGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/statistics',
                'operation_id': 'get_statistics',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'interval',
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                    'interval',
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-ID": "-id",
                        "-NAME": "-name",
                        "-ORG_ID": "-org_id",
                        "-TIME": "-time",
                        "-TYPE": "-type",
                        "-VALUE": "-value",
                        "ID": "id",
                        "NAME": "name",
                        "ORG_ID": "org_id",
                        "TIME": "time",
                        "TYPE": "type",
                        "VALUE": "value"
                    },
                },
                'openapi_types': {
                    'interval':
                        (int, none_type,),
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'interval': 'interval',
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'interval': 'query',
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_tagcounts_endpoint = _Endpoint(
            settings={
                'response_type': (TagcountsGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/tagcounts',
                'operation_id': 'get_tagcounts',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-ALL_COUNT": "-all_count",
                        "-CONTENT": "-content",
                        "-HOSTNAME_COUNT": "-hostname_count",
                        "-ID": "-id",
                        "-IP_COUNT": "-ip_count",
                        "-IS_CHARACTERISTIC_TAG": "-is_characteristic_tag",
                        "-NETWORK_COUNT": "-network_count",
                        "-ORG_ID": "-org_id",
                        "-POC_COUNT": "-poc_count",
                        "-SERVICE_COUNT": "-service_count",
                        "-TARGET_COUNT": "-target_count",
                        "ALL_COUNT": "all_count",
                        "CONTENT": "content",
                        "HOSTNAME_COUNT": "hostname_count",
                        "ID": "id",
                        "IP_COUNT": "ip_count",
                        "IS_CHARACTERISTIC_TAG": "is_characteristic_tag",
                        "NETWORK_COUNT": "network_count",
                        "ORG_ID": "org_id",
                        "POC_COUNT": "poc_count",
                        "SERVICE_COUNT": "service_count",
                        "TARGET_COUNT": "target_count"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_target_endpoint = _Endpoint(
            settings={
                'response_type': (TargetGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/target',
                'operation_id': 'get_target',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-AFFILIATION_STATE": "-affiliation_state",
                        "-APPLICABILITY": "-applicability",
                        "-ATTACK_NOTE": "-attack_note",
                        "-AUTHORITY": "-authority",
                        "-AUTHORITY_DISTANCE": "-authority_distance",
                        "-AUTHORITY_OVERRIDE": "-authority_override",
                        "-AUTHORIZATION_STATE": "-authorization_state",
                        "-CHARACTERISTIC_TAGS": "-characteristic_tags",
                        "-CONFIDENCE": "-confidence",
                        "-CPE": "-cpe",
                        "-CRITICALITY": "-criticality",
                        "-DELETED": "-deleted",
                        "-DESCRIPTION": "-description",
                        "-DESCRIPTION_SOURCE": "-description_source",
                        "-DETECTION_CRITERIA": "-detection_criteria",
                        "-ENUMERABILITY": "-enumerability",
                        "-FIRST_SEEN": "-first_seen",
                        "-ID": "-id",
                        "-IMPACT_SCORE": "-impact_score",
                        "-LAST_SEEN": "-last_seen",
                        "-LENS_ID": "-lens_id",
                        "-LENS_VIEW": "-lens_view",
                        "-NAME": "-name",
                        "-ORG_ID": "-org_id",
                        "-PERSPECTIVE": "-perspective",
                        "-PERSPECTIVE_NAME": "-perspective_name",
                        "-POST_EXPLOIT": "-post_exploit",
                        "-PRIORITY_IMPACT_FACTOR": "-priority_impact_factor",
                        "-PRIORITY_SCORE": "-priority_score",
                        "-PRIORITY_STATUS_FACTOR": "-priority_status_factor",
                        "-PRIORITY_TAGS_FACTOR": "-priority_tags_factor",
                        "-PRIVATE_WEAKNESS": "-private_weakness",
                        "-PUBLIC_WEAKNESS": "-public_weakness",
                        "-RANDORI_NOTES": "-randori_notes",
                        "-REFERENCE": "-reference",
                        "-RESEARCH": "-research",
                        "-SERVICE_ID": "-service_id",
                        "-STATUS": "-status",
                        "-TARGET_TEMPTATION": "-target_temptation",
                        "-TECH_CATEGORY": "-tech_category",
                        "-TEMPTATION_LAST_MODIFIED": "-temptation_last_modified",
                        "-USER_TAGS": "-user_tags",
                        "-VALIDATED_VULNERABILITIES_TARGET": "-validated_vulnerabilities_target",
                        "-VALIDATED_VULNERABILITIES_TARGET_COUNT": "-validated_vulnerabilities_target_count",
                        "-VENDOR": "-vendor",
                        "-VERSION": "-version",
                        "AFFILIATION_STATE": "affiliation_state",
                        "APPLICABILITY": "applicability",
                        "ATTACK_NOTE": "attack_note",
                        "AUTHORITY": "authority",
                        "AUTHORITY_DISTANCE": "authority_distance",
                        "AUTHORITY_OVERRIDE": "authority_override",
                        "AUTHORIZATION_STATE": "authorization_state",
                        "CHARACTERISTIC_TAGS": "characteristic_tags",
                        "CONFIDENCE": "confidence",
                        "CPE": "cpe",
                        "CRITICALITY": "criticality",
                        "DELETED": "deleted",
                        "DESCRIPTION": "description",
                        "DESCRIPTION_SOURCE": "description_source",
                        "DETECTION_CRITERIA": "detection_criteria",
                        "ENUMERABILITY": "enumerability",
                        "FIRST_SEEN": "first_seen",
                        "ID": "id",
                        "IMPACT_SCORE": "impact_score",
                        "LAST_SEEN": "last_seen",
                        "LENS_ID": "lens_id",
                        "LENS_VIEW": "lens_view",
                        "NAME": "name",
                        "ORG_ID": "org_id",
                        "PERSPECTIVE": "perspective",
                        "PERSPECTIVE_NAME": "perspective_name",
                        "POST_EXPLOIT": "post_exploit",
                        "PRIORITY_IMPACT_FACTOR": "priority_impact_factor",
                        "PRIORITY_SCORE": "priority_score",
                        "PRIORITY_STATUS_FACTOR": "priority_status_factor",
                        "PRIORITY_TAGS_FACTOR": "priority_tags_factor",
                        "PRIVATE_WEAKNESS": "private_weakness",
                        "PUBLIC_WEAKNESS": "public_weakness",
                        "RANDORI_NOTES": "randori_notes",
                        "REFERENCE": "reference",
                        "RESEARCH": "research",
                        "SERVICE_ID": "service_id",
                        "STATUS": "status",
                        "TARGET_TEMPTATION": "target_temptation",
                        "TECH_CATEGORY": "tech_category",
                        "TEMPTATION_LAST_MODIFIED": "temptation_last_modified",
                        "USER_TAGS": "user_tags",
                        "VALIDATED_VULNERABILITIES_TARGET": "validated_vulnerabilities_target",
                        "VALIDATED_VULNERABILITIES_TARGET_COUNT": "validated_vulnerabilities_target_count",
                        "VENDOR": "vendor",
                        "VERSION": "version"
                    },
                },
                'openapi_types': {
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_user_endpoint = _Endpoint(
            settings={
                'response_type': (UserGetOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/user',
                'operation_id': 'get_user',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'current_org_only',
                    'offset',
                    'limit',
                    'sort',
                    'q',
                    'reversed_nulls',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('sort',): {

                        "-CREATED_ON": "-created_on",
                        "-EMAIL": "-email",
                        "-ID": "-id",
                        "-LAST_LOGIN": "-last_login",
                        "-LOCK_EXPIRY": "-lock_expiry",
                        "-LOCK_REASON": "-lock_reason",
                        "-LOCKED": "-locked",
                        "-LOGIN_TYPE": "-login_type",
                        "-MANAGED_PERSONNEL": "-managed_personnel",
                        "-NAME": "-name",
                        "-PASSWORD_FAILURES": "-password_failures",
                        "-TITLE": "-title",
                        "-TOS_DATE": "-tos_date",
                        "-TOS_VERSION": "-tos_version",
                        "-TOTP_FAILURES": "-totp_failures",
                        "-USERNAME": "-username",
                        "-VIEW_ORG": "-view_org",
                        "CREATED_ON": "created_on",
                        "EMAIL": "email",
                        "ID": "id",
                        "LAST_LOGIN": "last_login",
                        "LOCK_EXPIRY": "lock_expiry",
                        "LOCK_REASON": "lock_reason",
                        "LOCKED": "locked",
                        "LOGIN_TYPE": "login_type",
                        "MANAGED_PERSONNEL": "managed_personnel",
                        "NAME": "name",
                        "PASSWORD_FAILURES": "password_failures",
                        "TITLE": "title",
                        "TOS_DATE": "tos_date",
                        "TOS_VERSION": "tos_version",
                        "TOTP_FAILURES": "totp_failures",
                        "USERNAME": "username",
                        "VIEW_ORG": "view_org"
                    },
                },
                'openapi_types': {
                    'current_org_only':
                        (bool,),
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                    'sort':
                        ([str],),
                    'q':
                        (str,),
                    'reversed_nulls':
                        (bool,),
                },
                'attribute_map': {
                    'current_org_only': 'current_org_only',
                    'offset': 'offset',
                    'limit': 'limit',
                    'sort': 'sort',
                    'q': 'q',
                    'reversed_nulls': 'reversed_nulls',
                },
                'location_map': {
                    'current_org_only': 'query',
                    'offset': 'query',
                    'limit': 'query',
                    'sort': 'query',
                    'q': 'query',
                    'reversed_nulls': 'query',
                },
                'collection_format_map': {
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.login_endpoint = _Endpoint(
            settings={
                'response_type': (DefaultOutputSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/login',
                'operation_id': 'login',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'username_password_input_schema',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'username_password_input_schema':
                        (UsernamePasswordInputSchema,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'username_password_input_schema': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.login_otp_endpoint = _Endpoint(
            settings={
                'response_type': (DefaultOutputSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/login-otp',
                'operation_id': 'login_otp',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'otp_token_input_schema',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'otp_token_input_schema':
                        (OtpTokenInputSchema,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'otp_token_input_schema': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.logout_endpoint = _Endpoint(
            settings={
                'response_type': (DefaultOutputSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/logout',
                'operation_id': 'logout',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'logout_input_schema',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'logout_input_schema':
                        (LogoutInputSchema,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'logout_input_schema': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.manual_authorization_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/manual-authorization',
                'operation_id': 'manual_authorization',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'manual_authorization_request',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'manual_authorization_request':
                        (ManualAuthorizationRequest,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'manual_authorization_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.mitre_mitigation_endpoint = _Endpoint(
            settings={
                'response_type': (MitreMitigation,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/mitre/mitigation/{mitre_code}',
                'operation_id': 'mitre_mitigation',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'mitre_code',
                ],
                'required': [
                    'mitre_code',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'mitre_code':
                        (str,),
                },
                'attribute_map': {
                    'mitre_code': 'mitre_code',
                },
                'location_map': {
                    'mitre_code': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.mitre_tactic_endpoint = _Endpoint(
            settings={
                'response_type': (MitreTactic,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/mitre/tactic/{mitre_code}',
                'operation_id': 'mitre_tactic',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'mitre_code',
                ],
                'required': [
                    'mitre_code',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'mitre_code':
                        (str,),
                },
                'attribute_map': {
                    'mitre_code': 'mitre_code',
                },
                'location_map': {
                    'mitre_code': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.mitre_technique_endpoint = _Endpoint(
            settings={
                'response_type': (MitreTechnique,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/mitre/technique/{mitre_code}',
                'operation_id': 'mitre_technique',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'mitre_code',
                ],
                'required': [
                    'mitre_code',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'mitre_code':
                        (str,),
                },
                'attribute_map': {
                    'mitre_code': 'mitre_code',
                },
                'location_map': {
                    'mitre_code': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.org_with_feature_endpoint = _Endpoint(
            settings={
                'response_type': (OrgWithFeatureResponseCollection,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/org_with_feature',
                'operation_id': 'org_with_feature',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'feature_name',
                    'org_list',
                ],
                'required': [
                    'feature_name',
                ],
                'nullable': [
                    'org_list',
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'feature_name':
                        (str,),
                    'org_list':
                        ([str], none_type,),
                },
                'attribute_map': {
                    'feature_name': 'feature_name',
                    'org_list': 'org_list',
                },
                'location_map': {
                    'feature_name': 'query',
                    'org_list': 'query',
                },
                'collection_format_map': {
                    'org_list': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.patch_comment_endpoint = _Endpoint(
            settings={
                'response_type': (CommentResponseSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/entity/{entity_id}/comment/{comment_id}',
                'operation_id': 'patch_comment',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'comment_id',
                    'entity_id',
                    'comment_creation_schema',
                ],
                'required': [
                    'comment_id',
                    'entity_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'comment_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'comment_creation_schema':
                        (CommentCreationSchema,),
                },
                'attribute_map': {
                    'comment_id': 'comment_id',
                    'entity_id': 'entity_id',
                },
                'location_map': {
                    'comment_id': 'path',
                    'entity_id': 'path',
                    'comment_creation_schema': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.patch_hostname_endpoint = _Endpoint(
            settings={
                'response_type': (HostnamePatchOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/hostname',
                'operation_id': 'patch_hostname',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'hostname_patch_input',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'hostname_patch_input':
                        (HostnamePatchInput,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'hostname_patch_input': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.patch_ip_endpoint = _Endpoint(
            settings={
                'response_type': (IpPatchOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/ip',
                'operation_id': 'patch_ip',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'ip_patch_input',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'ip_patch_input':
                        (IpPatchInput,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'ip_patch_input': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.patch_network_endpoint = _Endpoint(
            settings={
                'response_type': (NetworkPatchOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/network',
                'operation_id': 'patch_network',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'network_patch_input',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'network_patch_input':
                        (NetworkPatchInput,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'network_patch_input': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.patch_single_saved_views_endpoint = _Endpoint(
            settings={
                'response_type': (SavedViewsSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/saved-views/{id}',
                'operation_id': 'patch_single_saved_views',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'saved_views_patch_single_input',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'saved_views_patch_single_input':
                        (SavedViewsPatchSingleInput,),
                },
                'attribute_map': {
                    'id': 'id',
                },
                'location_map': {
                    'id': 'path',
                    'saved_views_patch_single_input': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.patch_single_user_endpoint = _Endpoint(
            settings={
                'response_type': (UserSingleOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/user/{id}',
                'operation_id': 'patch_single_user',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                    'user_patch_single_input',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                    'user_patch_single_input':
                        (UserPatchSingleInput,),
                },
                'attribute_map': {
                    'id': 'id',
                },
                'location_map': {
                    'id': 'path',
                    'user_patch_single_input': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.patch_social_entity_endpoint = _Endpoint(
            settings={
                'response_type': (SocialEntityPatchOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/social-entity',
                'operation_id': 'patch_social_entity',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'social_entity_patch_input',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'social_entity_patch_input':
                        (SocialEntityPatchInput,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'social_entity_patch_input': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.patch_target_endpoint = _Endpoint(
            settings={
                'response_type': (TargetPatchOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/target',
                'operation_id': 'patch_target',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'target_patch_input',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'target_patch_input':
                        (TargetPatchInput,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'target_patch_input': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.paths_endpoint = _Endpoint(
            settings={
                'response_type': (PathsOutputSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/paths',
                'operation_id': 'paths',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'terminal',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'terminal':
                        (str,),
                },
                'attribute_map': {
                    'terminal': 'terminal',
                },
                'location_map': {
                    'terminal': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.permission_group_types_endpoint = _Endpoint(
            settings={
                'response_type': (PermissionGroupsInfo,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/permission-group-types',
                'operation_id': 'permission_group_types',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.permission_groups_read_endpoint = _Endpoint(
            settings={
                'response_type': (PermissionGroup,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/permission-groups',
                'operation_id': 'permission_groups_read',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'target_user_id',
                ],
                'required': [
                    'target_user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'target_user_id':
                        (str,),
                },
                'attribute_map': {
                    'target_user_id': 'target_user_id',
                },
                'location_map': {
                    'target_user_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.post_comment_endpoint = _Endpoint(
            settings={
                'response_type': (CommentResponseSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/entity/{entity_id}/comment',
                'operation_id': 'post_comment',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'entity_id',
                    'comment_creation_schema',
                ],
                'required': [
                    'entity_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'entity_id':
                        (str,),
                    'comment_creation_schema':
                        (CommentCreationSchema,),
                },
                'attribute_map': {
                    'entity_id': 'entity_id',
                },
                'location_map': {
                    'entity_id': 'path',
                    'comment_creation_schema': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.post_comment_multi_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/comment',
                'operation_id': 'post_comment_multi',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'external_comment_creation_schema',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'external_comment_creation_schema':
                        (ExternalCommentCreationSchema,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'external_comment_creation_schema': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.post_saved_views_endpoint = _Endpoint(
            settings={
                'response_type': (SavedViewsPostOutput,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/saved-views',
                'operation_id': 'post_saved_views',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'saved_views_post_input',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'saved_views_post_input':
                        (SavedViewsPostInput,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'saved_views_post_input': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.recon_worker_node_ips_endpoint = _Endpoint(
            settings={
                'response_type': (ReconWorkerNodeIps,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/recon-worker-node-ips',
                'operation_id': 'recon_worker_node_ips',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'ips',
                    'lookbackdays',
                ],
                'required': [
                    'ips',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'ips':
                        (str,),
                    'lookbackdays':
                        (int,),
                },
                'attribute_map': {
                    'ips': 'ips',
                    'lookbackdays': 'lookbackdays',
                },
                'location_map': {
                    'ips': 'query',
                    'lookbackdays': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.renew_endpoint = _Endpoint(
            settings={
                'response_type': (DefaultOutputSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/renew',
                'operation_id': 'renew',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'logout_input_schema',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'logout_input_schema':
                        (LogoutInputSchema,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'logout_input_schema': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.renew_api_token_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/renew-api-token',
                'operation_id': 'renew_api_token',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.tag_endpoint = _Endpoint(
            settings={
                'response_type': (UserTagNameList,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/recon/api/v1/tag',
                'operation_id': 'tag',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.uuid_artifactsource_uuid_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/artifactstore/api/v1/retrieve-artifact/{artifactsource_uuid}',
                'operation_id': 'uuid_artifactsource_uuid',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'artifactsource_uuid',
                    'activity_instance_id',
                ],
                'required': [
                    'artifactsource_uuid',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'artifactsource_uuid':
                        (str,),
                    'activity_instance_id':
                        (str,),
                },
                'attribute_map': {
                    'artifactsource_uuid': 'artifactsource_uuid',
                    'activity_instance_id': 'activity_instance_id',
                },
                'location_map': {
                    'artifactsource_uuid': 'path',
                    'activity_instance_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.validate_endpoint = _Endpoint(
            settings={
                'response_type': (TokenOutputSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/validate',
                'operation_id': 'validate',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'token_input_schema',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'token_input_schema':
                        (TokenInputSchema,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'token_input_schema': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.validate_user_jwt_endpoint = _Endpoint(
            settings={
                'response_type': (TokenOutputSchema,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/auth/api/v1/validate',
                'operation_id': 'validate_user_jwt',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )

    def add_affiliation_file(
        self,
        **kwargs
    ):
        """add_affiliation_file  # noqa: E501

        Add a file of missing affiliations for an organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_affiliation_file(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.add_affiliation_file_endpoint.call_with_http_info(**kwargs)

    def artifacts(
        self,
        activity_instance_id,
        **kwargs
    ):
        """artifacts  # noqa: E501

        This returns all renderable artifacts for an activity instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.artifacts(activity_instance_id, async_req=True)
        >>> result = thread.get()

        Args:
            activity_instance_id (str):

        Keyword Args:
            offset (int): [optional]
            limit (int): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArtifactForActivityResponseCollectionSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['activity_instance_id'] = \
            activity_instance_id
        return self.artifacts_endpoint.call_with_http_info(**kwargs)

    def change_password(
        self,
        **kwargs
    ):
        """change_password  # noqa: E501

        Change the password for the jwt user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.change_password(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            password_change_schema (PasswordChangeSchema): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DefaultOutputSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.change_password_endpoint.call_with_http_info(**kwargs)

    def delete_comment(
        self,
        comment_id,
        entity_id,
        **kwargs
    ):
        """delete_comment  # noqa: E501

        Deletes an existing comment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_comment(comment_id, entity_id, async_req=True)
        >>> result = thread.get()

        Args:
            comment_id (str):
            entity_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            CommentResponseSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['comment_id'] = \
            comment_id
        kwargs['entity_id'] = \
            entity_id
        return self.delete_comment_endpoint.call_with_http_info(**kwargs)

    def delete_single_saved_views(
        self,
        id,
        **kwargs
    ):
        """delete_single_saved_views  # noqa: E501

        Remove the saved-views object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_single_saved_views(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            saved_views_single_input (SavedViewsSingleInput): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.delete_single_saved_views_endpoint.call_with_http_info(**kwargs)

    def features(
        self,
        **kwargs
    ):
        """features  # noqa: E501

        Retrieve defined features.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.features(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            feature_names ([str]): [optional]
            feature_types ([str]): [optional]
            active_only (bool): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            FeatureResponseCollection
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.features_endpoint.call_with_http_info(**kwargs)

    def features_org(
        self,
        **kwargs
    ):
        """features_org  # noqa: E501

        Retrieve an organization's features.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.features_org(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            names ([str]): [optional]
            org_uuid (str): [optional]
            active_only (bool): [optional]
            return_all (bool): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            OrgFeatureResponseCollection
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.features_org_endpoint.call_with_http_info(**kwargs)

    def get_action_metadata(
        self,
        **kwargs
    ):
        """get_action_metadata  # noqa: E501

        Search action-metadata objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_action_metadata(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ActionMetadataGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_action_metadata_endpoint.call_with_http_info(**kwargs)

    def get_activity_log(
        self,
        **kwargs
    ):
        """get_activity_log  # noqa: E501

        Search activity-log objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_activity_log(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ActivityLogGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_activity_log_endpoint.call_with_http_info(**kwargs)

    def get_all_detections_for_target(
        self,
        **kwargs
    ):
        """get_all_detections_for_target  # noqa: E501

        Search all-detections-for-target objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_all_detections_for_target(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            AllDetectionsForTargetGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_all_detections_for_target_endpoint.call_with_http_info(**kwargs)

    def get_attack_checkins_for_implant(
        self,
        **kwargs
    ):
        """get_attack_checkins_for_implant  # noqa: E501

        Search attack-checkins-for-implant objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_attack_checkins_for_implant(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            AttackCheckinsForImplantGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_attack_checkins_for_implant_endpoint.call_with_http_info(**kwargs)

    def get_attack_implants(
        self,
        **kwargs
    ):
        """get_attack_implants  # noqa: E501

        Search attack-implants objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_attack_implants(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            AttackImplantsGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_attack_implants_endpoint.call_with_http_info(**kwargs)

    def get_attack_interfaces_for_implant(
        self,
        **kwargs
    ):
        """get_attack_interfaces_for_implant  # noqa: E501

        Search attack-interfaces-for-implant objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_attack_interfaces_for_implant(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            AttackInterfacesForImplantGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_attack_interfaces_for_implant_endpoint.call_with_http_info(**kwargs)

    def get_attack_redirectors(
        self,
        **kwargs
    ):
        """get_attack_redirectors  # noqa: E501

        Search attack-redirectors objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_attack_redirectors(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            AttackRedirectorsGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_attack_redirectors_endpoint.call_with_http_info(**kwargs)

    def get_attack_runbook(
        self,
        **kwargs
    ):
        """get_attack_runbook  # noqa: E501

        Search attack-runbook objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_attack_runbook(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            AttackRunbookGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_attack_runbook_endpoint.call_with_http_info(**kwargs)

    def get_attack_statistics(
        self,
        **kwargs
    ):
        """get_attack_statistics  # noqa: E501

        Search attack-statistics objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_attack_statistics(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            AttackStatisticsGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_attack_statistics_endpoint.call_with_http_info(**kwargs)

    def get_authorization_policy(
        self,
        **kwargs
    ):
        """get_authorization_policy  # noqa: E501

        Search authorization-policy objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_authorization_policy(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            AuthorizationPolicyGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_authorization_policy_endpoint.call_with_http_info(**kwargs)

    def get_comment(
        self,
        entity_id,
        **kwargs
    ):
        """get_comment  # noqa: E501

        Retrieves a page of comments for a provided entity ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_comment(entity_id, async_req=True)
        >>> result = thread.get()

        Args:
            entity_id (str):

        Keyword Args:
            offset (int): [optional]
            limit (int): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            CommentResponseCollectionSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['entity_id'] = \
            entity_id
        return self.get_comment_endpoint.call_with_http_info(**kwargs)

    def get_guidance_file(
        self,
        tag,
        **kwargs
    ):
        """get_guidance_file  # noqa: E501

        Retrieve Randori guidance as markdown by tag  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_guidance_file(tag, async_req=True)
        >>> result = thread.get()

        Args:
            tag (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['tag'] = \
            tag
        return self.get_guidance_file_endpoint.call_with_http_info(**kwargs)

    def get_hostname(
        self,
        **kwargs
    ):
        """get_hostname  # noqa: E501

        Search hostname objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_hostname(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            HostnameGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_hostname_endpoint.call_with_http_info(**kwargs)

    def get_hostnames_for_ip(
        self,
        **kwargs
    ):
        """get_hostnames_for_ip  # noqa: E501

        Search hostnames-for-ip objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_hostnames_for_ip(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            HostnamesForIpGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_hostnames_for_ip_endpoint.call_with_http_info(**kwargs)

    def get_ip(
        self,
        **kwargs
    ):
        """get_ip  # noqa: E501

        Search ip objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_ip(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            IpGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_ip_endpoint.call_with_http_info(**kwargs)

    def get_ips_for_hostname(
        self,
        **kwargs
    ):
        """get_ips_for_hostname  # noqa: E501

        Search ips-for-hostname objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_ips_for_hostname(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            IpsForHostnameGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_ips_for_hostname_endpoint.call_with_http_info(**kwargs)

    def get_ips_for_network(
        self,
        **kwargs
    ):
        """get_ips_for_network  # noqa: E501

        Search ips-for-network objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_ips_for_network(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            IpsForNetworkGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_ips_for_network_endpoint.call_with_http_info(**kwargs)

    def get_ips_for_service(
        self,
        **kwargs
    ):
        """get_ips_for_service  # noqa: E501

        Search ips-for-service objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_ips_for_service(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            IpsForServiceGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_ips_for_service_endpoint.call_with_http_info(**kwargs)

    def get_network(
        self,
        **kwargs
    ):
        """get_network  # noqa: E501

        Search network objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_network(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            NetworkGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_network_endpoint.call_with_http_info(**kwargs)

    def get_organization(
        self,
        **kwargs
    ):
        """get_organization  # noqa: E501

        Search organization objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_organization(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            OrganizationGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_organization_endpoint.call_with_http_info(**kwargs)

    def get_policy(
        self,
        **kwargs
    ):
        """get_policy  # noqa: E501

        Search policy objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_policy(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PolicyGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_policy_endpoint.call_with_http_info(**kwargs)

    def get_ports_for_ip(
        self,
        **kwargs
    ):
        """get_ports_for_ip  # noqa: E501

        Search ports-for-ip objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_ports_for_ip(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PortsForIpGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_ports_for_ip_endpoint.call_with_http_info(**kwargs)

    def get_preferences(
        self,
        **kwargs
    ):
        """get_preferences  # noqa: E501

        Retrieve preferences for a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_preferences(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            names ([str]): [optional]
            group_names ([str]): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PreferenceOutCollection
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_preferences_endpoint.call_with_http_info(**kwargs)

    def get_saved_views(
        self,
        **kwargs
    ):
        """get_saved_views  # noqa: E501

        Search saved-views objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_saved_views(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SavedViewsGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_saved_views_endpoint.call_with_http_info(**kwargs)

    def get_service(
        self,
        **kwargs
    ):
        """get_service  # noqa: E501

        Search service objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_service(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ServiceGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_service_endpoint.call_with_http_info(**kwargs)

    def get_single_action_metadata(
        self,
        id,
        **kwargs
    ):
        """get_single_action_metadata  # noqa: E501

        Get one action-metadata object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_action_metadata(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ActionMetadataSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_action_metadata_endpoint.call_with_http_info(**kwargs)

    def get_single_activity_log(
        self,
        id,
        **kwargs
    ):
        """get_single_activity_log  # noqa: E501

        Get one activity-log object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_activity_log(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ActivityLogSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_activity_log_endpoint.call_with_http_info(**kwargs)

    def get_single_attack_implants(
        self,
        id,
        **kwargs
    ):
        """get_single_attack_implants  # noqa: E501

        Get one attack-implants object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_attack_implants(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            AttackImplantsSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_attack_implants_endpoint.call_with_http_info(**kwargs)

    def get_single_detection_for_target(
        self,
        **kwargs
    ):
        """get_single_detection_for_target  # noqa: E501

        Search single-detection-for-target objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_detection_for_target(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SingleDetectionForTargetGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_single_detection_for_target_endpoint.call_with_http_info(**kwargs)

    def get_single_hostname(
        self,
        id,
        **kwargs
    ):
        """get_single_hostname  # noqa: E501

        Get one hostname object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_hostname(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            HostnameSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_hostname_endpoint.call_with_http_info(**kwargs)

    def get_single_hostnames_for_ip(
        self,
        id,
        **kwargs
    ):
        """get_single_hostnames_for_ip  # noqa: E501

        Get one hostnames-for-ip object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_hostnames_for_ip(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            HostnamesForIpSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_hostnames_for_ip_endpoint.call_with_http_info(**kwargs)

    def get_single_ip(
        self,
        id,
        **kwargs
    ):
        """get_single_ip  # noqa: E501

        Get one ip object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_ip(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            IpSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_ip_endpoint.call_with_http_info(**kwargs)

    def get_single_ips_for_hostname(
        self,
        id,
        **kwargs
    ):
        """get_single_ips_for_hostname  # noqa: E501

        Get one ips-for-hostname object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_ips_for_hostname(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            IpsForHostnameSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_ips_for_hostname_endpoint.call_with_http_info(**kwargs)

    def get_single_ips_for_network(
        self,
        id,
        **kwargs
    ):
        """get_single_ips_for_network  # noqa: E501

        Get one ips-for-network object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_ips_for_network(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            IpsForNetworkSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_ips_for_network_endpoint.call_with_http_info(**kwargs)

    def get_single_ips_for_service(
        self,
        id,
        **kwargs
    ):
        """get_single_ips_for_service  # noqa: E501

        Get one ips-for-service object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_ips_for_service(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            IpsForServiceSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_ips_for_service_endpoint.call_with_http_info(**kwargs)

    def get_single_network(
        self,
        id,
        **kwargs
    ):
        """get_single_network  # noqa: E501

        Get one network object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_network(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            NetworkSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_network_endpoint.call_with_http_info(**kwargs)

    def get_single_organization(
        self,
        id,
        **kwargs
    ):
        """get_single_organization  # noqa: E501

        Get one organization object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_organization(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            OrganizationSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_organization_endpoint.call_with_http_info(**kwargs)

    def get_single_ports_for_ip(
        self,
        id,
        **kwargs
    ):
        """get_single_ports_for_ip  # noqa: E501

        Get one ports-for-ip object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_ports_for_ip(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PortsForIpSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_ports_for_ip_endpoint.call_with_http_info(**kwargs)

    def get_single_saved_views(
        self,
        id,
        **kwargs
    ):
        """get_single_saved_views  # noqa: E501

        Get one saved-views object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_saved_views(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SavedViewsSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_saved_views_endpoint.call_with_http_info(**kwargs)

    def get_single_service(
        self,
        id,
        **kwargs
    ):
        """get_single_service  # noqa: E501

        Get one service object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_service(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ServiceSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_service_endpoint.call_with_http_info(**kwargs)

    def get_single_tagcounts(
        self,
        id,
        **kwargs
    ):
        """get_single_tagcounts  # noqa: E501

        Get one tagcounts object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_tagcounts(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            TagcountsSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_tagcounts_endpoint.call_with_http_info(**kwargs)

    def get_single_target(
        self,
        id,
        **kwargs
    ):
        """get_single_target  # noqa: E501

        Get one target object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_target(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            TargetSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_target_endpoint.call_with_http_info(**kwargs)

    def get_single_user(
        self,
        id,
        **kwargs
    ):
        """get_single_user  # noqa: E501

        Get one user object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_single_user(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            UserSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.get_single_user_endpoint.call_with_http_info(**kwargs)

    def get_social_entity(
        self,
        **kwargs
    ):
        """get_social_entity  # noqa: E501

        Search social-entity objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_social_entity(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SocialEntityGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_social_entity_endpoint.call_with_http_info(**kwargs)

    def get_statistics(
        self,
        **kwargs
    ):
        """get_statistics  # noqa: E501

        Search statistics objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_statistics(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            interval (int, none_type): number of records to skip between responses. [optional]
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            StatisticsGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_statistics_endpoint.call_with_http_info(**kwargs)

    def get_tagcounts(
        self,
        **kwargs
    ):
        """get_tagcounts  # noqa: E501

        Search tagcounts objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tagcounts(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            TagcountsGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_tagcounts_endpoint.call_with_http_info(**kwargs)

    def get_target(
        self,
        **kwargs
    ):
        """get_target  # noqa: E501

        Search target objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_target(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            TargetGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_target_endpoint.call_with_http_info(**kwargs)

    def get_user(
        self,
        **kwargs
    ):
        """get_user  # noqa: E501

        Search user objects with an optional filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            current_org_only (bool): [optional] if omitted the server will use the default value of False
            offset (int): offset into avilable records after filtering. [optional]
            limit (int): maximum number of records to return. [optional]
            sort ([str]): fields in the object to sort by, in order of precedence, minus indicates descending. [optional]
            q (str): base64 encoded jquery querybuilder complex search field. [optional]
            reversed_nulls (bool): if true, sorts nulls as if smaller than any nonnull value for all sort parameters. otherwise (default) treats as if larger. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            UserGetOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_user_endpoint.call_with_http_info(**kwargs)

    def login(
        self,
        **kwargs
    ):
        """login  # noqa: E501

        Login with credentials.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.login(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username_password_input_schema (UsernamePasswordInputSchema): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DefaultOutputSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.login_endpoint.call_with_http_info(**kwargs)

    def login_otp(
        self,
        **kwargs
    ):
        """login_otp  # noqa: E501

        Complete login with the current OTP.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.login_otp(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            otp_token_input_schema (OtpTokenInputSchema): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DefaultOutputSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.login_otp_endpoint.call_with_http_info(**kwargs)

    def logout(
        self,
        **kwargs
    ):
        """logout  # noqa: E501

        Logout the current JWT or another JWT owned by the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.logout(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            logout_input_schema (LogoutInputSchema): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DefaultOutputSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.logout_endpoint.call_with_http_info(**kwargs)

    def manual_authorization(
        self,
        **kwargs
    ):
        """manual_authorization  # noqa: E501

        Given a list of detection uuids and an action, will apply that action to those dections  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.manual_authorization(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            manual_authorization_request (ManualAuthorizationRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.manual_authorization_endpoint.call_with_http_info(**kwargs)

    def mitre_mitigation(
        self,
        mitre_code,
        **kwargs
    ):
        """mitre_mitigation  # noqa: E501

        Given a valid mitre mitigation code, will return details about that mitigation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mitre_mitigation(mitre_code, async_req=True)
        >>> result = thread.get()

        Args:
            mitre_code (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            MitreMitigation
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['mitre_code'] = \
            mitre_code
        return self.mitre_mitigation_endpoint.call_with_http_info(**kwargs)

    def mitre_tactic(
        self,
        mitre_code,
        **kwargs
    ):
        """mitre_tactic  # noqa: E501

        Given a valid mitre tactic code, will return details about that tactic  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mitre_tactic(mitre_code, async_req=True)
        >>> result = thread.get()

        Args:
            mitre_code (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            MitreTactic
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['mitre_code'] = \
            mitre_code
        return self.mitre_tactic_endpoint.call_with_http_info(**kwargs)

    def mitre_technique(
        self,
        mitre_code,
        **kwargs
    ):
        """mitre_technique  # noqa: E501

        Given a valid mitre technique code, will return details about that technique  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mitre_technique(mitre_code, async_req=True)
        >>> result = thread.get()

        Args:
            mitre_code (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            MitreTechnique
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['mitre_code'] = \
            mitre_code
        return self.mitre_technique_endpoint.call_with_http_info(**kwargs)

    def org_with_feature(
        self,
        feature_name,
        **kwargs
    ):
        """org_with_feature  # noqa: E501

        Retrieve organization with active features.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.org_with_feature(feature_name, async_req=True)
        >>> result = thread.get()

        Args:
            feature_name (str):

        Keyword Args:
            org_list ([str], none_type): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            OrgWithFeatureResponseCollection
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['feature_name'] = \
            feature_name
        return self.org_with_feature_endpoint.call_with_http_info(**kwargs)

    def patch_comment(
        self,
        comment_id,
        entity_id,
        **kwargs
    ):
        """patch_comment  # noqa: E501

        Updates an existing comment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_comment(comment_id, entity_id, async_req=True)
        >>> result = thread.get()

        Args:
            comment_id (str):
            entity_id (str):

        Keyword Args:
            comment_creation_schema (CommentCreationSchema): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            CommentResponseSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['comment_id'] = \
            comment_id
        kwargs['entity_id'] = \
            entity_id
        return self.patch_comment_endpoint.call_with_http_info(**kwargs)

    def patch_hostname(
        self,
        **kwargs
    ):
        """patch_hostname  # noqa: E501

        bulk-patch hostname records  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_hostname(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            hostname_patch_input (HostnamePatchInput): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            HostnamePatchOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.patch_hostname_endpoint.call_with_http_info(**kwargs)

    def patch_ip(
        self,
        **kwargs
    ):
        """patch_ip  # noqa: E501

        bulk-patch ip records  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_ip(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            ip_patch_input (IpPatchInput): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            IpPatchOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.patch_ip_endpoint.call_with_http_info(**kwargs)

    def patch_network(
        self,
        **kwargs
    ):
        """patch_network  # noqa: E501

        bulk-patch network records  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_network(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            network_patch_input (NetworkPatchInput): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            NetworkPatchOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.patch_network_endpoint.call_with_http_info(**kwargs)

    def patch_single_saved_views(
        self,
        id,
        **kwargs
    ):
        """patch_single_saved_views  # noqa: E501

        Update fields for the saved-views object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_single_saved_views(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            saved_views_patch_single_input (SavedViewsPatchSingleInput): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SavedViewsSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.patch_single_saved_views_endpoint.call_with_http_info(**kwargs)

    def patch_single_user(
        self,
        id,
        **kwargs
    ):
        """patch_single_user  # noqa: E501

        Update fields for the user object by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_single_user(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (str):

        Keyword Args:
            user_patch_single_input (UserPatchSingleInput): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            UserSingleOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['id'] = \
            id
        return self.patch_single_user_endpoint.call_with_http_info(**kwargs)

    def patch_social_entity(
        self,
        **kwargs
    ):
        """patch_social_entity  # noqa: E501

        bulk-patch social-entity records  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_social_entity(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            social_entity_patch_input (SocialEntityPatchInput): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SocialEntityPatchOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.patch_social_entity_endpoint.call_with_http_info(**kwargs)

    def patch_target(
        self,
        **kwargs
    ):
        """patch_target  # noqa: E501

        bulk-patch target records  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_target(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            target_patch_input (TargetPatchInput): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            TargetPatchOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.patch_target_endpoint.call_with_http_info(**kwargs)

    def paths(
        self,
        **kwargs
    ):
        """paths  # noqa: E501

        Returns paths from query param to nearest prime entity(s)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.paths(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            terminal (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PathsOutputSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.paths_endpoint.call_with_http_info(**kwargs)

    def permission_group_types(
        self,
        **kwargs
    ):
        """permission_group_types  # noqa: E501

        Retrieve valid permission group types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.permission_group_types(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PermissionGroupsInfo
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.permission_group_types_endpoint.call_with_http_info(**kwargs)

    def permission_groups_read(
        self,
        target_user_id,
        **kwargs
    ):
        """permission_groups_read  # noqa: E501

        Retrieve permission groups for a user in the currently viewed organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.permission_groups_read(target_user_id, async_req=True)
        >>> result = thread.get()

        Args:
            target_user_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PermissionGroup
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['target_user_id'] = \
            target_user_id
        return self.permission_groups_read_endpoint.call_with_http_info(**kwargs)

    def post_comment(
        self,
        entity_id,
        **kwargs
    ):
        """post_comment  # noqa: E501

        Creates a single comment for a provided entity ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_comment(entity_id, async_req=True)
        >>> result = thread.get()

        Args:
            entity_id (str):

        Keyword Args:
            comment_creation_schema (CommentCreationSchema): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            CommentResponseSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['entity_id'] = \
            entity_id
        return self.post_comment_endpoint.call_with_http_info(**kwargs)

    def post_comment_multi(
        self,
        **kwargs
    ):
        """post_comment_multi  # noqa: E501

        Creates a single comment for multiple entity IDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_comment_multi(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            external_comment_creation_schema (ExternalCommentCreationSchema): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.post_comment_multi_endpoint.call_with_http_info(**kwargs)

    def post_saved_views(
        self,
        **kwargs
    ):
        """post_saved_views  # noqa: E501

        Add new saved-views objects  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_saved_views(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            saved_views_post_input (SavedViewsPostInput): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SavedViewsPostOutput
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.post_saved_views_endpoint.call_with_http_info(**kwargs)

    def recon_worker_node_ips(
        self,
        ips,
        **kwargs
    ):
        """recon_worker_node_ips  # noqa: E501

        Return IP addresses supplied, with a boolean value key indicating whether the IP was used by Randori in reconnaissance in (up to) the last 30 days. Note: the IP addresses must be a list of strings that is base64 encoded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.recon_worker_node_ips(ips, async_req=True)
        >>> result = thread.get()

        Args:
            ips (str):

        Keyword Args:
            lookbackdays (int): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ReconWorkerNodeIps
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['ips'] = \
            ips
        return self.recon_worker_node_ips_endpoint.call_with_http_info(**kwargs)

    def renew(
        self,
        **kwargs
    ):
        """renew  # noqa: E501

        Renew the user token if it is valid  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.renew(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            logout_input_schema (LogoutInputSchema): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DefaultOutputSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.renew_endpoint.call_with_http_info(**kwargs)

    def renew_api_token(
        self,
        **kwargs
    ):
        """renew_api_token  # noqa: E501

        Invalidates current session of an API token, and clones it into a new token/session. A way to rotate an API token value without changing anything else about it  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.renew_api_token(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.renew_api_token_endpoint.call_with_http_info(**kwargs)

    def tag(
        self,
        **kwargs
    ):
        """tag  # noqa: E501

        Return list of all tags present on system that belong belong to an entity alive in the last day  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tag(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            UserTagNameList
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.tag_endpoint.call_with_http_info(**kwargs)

    def uuid_artifactsource_uuid(
        self,
        artifactsource_uuid,
        **kwargs
    ):
        """uuid_artifactsource_uuid  # noqa: E501

        Returns the raw artifact for the given artifact instance id provided  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.uuid_artifactsource_uuid(artifactsource_uuid, async_req=True)
        >>> result = thread.get()

        Args:
            artifactsource_uuid (str):

        Keyword Args:
            activity_instance_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['artifactsource_uuid'] = \
            artifactsource_uuid
        return self.uuid_artifactsource_uuid_endpoint.call_with_http_info(**kwargs)

    def validate(
        self,
        **kwargs
    ):
        """validate  # noqa: E501

        Validate provided tokens  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            token_input_schema (TokenInputSchema): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            TokenOutputSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.validate_endpoint.call_with_http_info(**kwargs)

    def validate_user_jwt(
        self,
        **kwargs
    ):
        """validate_user_jwt  # noqa: E501

        Validate user token from auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_user_jwt(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            TokenOutputSchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.validate_user_jwt_endpoint.call_with_http_info(**kwargs)

