# coding: utf-8

"""
    Randori API

    Endpoints accessible using API tokens

    The version of the OpenAPI document: 1.0
    Contact: support@randori.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel, StrictInt, StrictStr
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class ActivityLog(BaseModel):
    """
    ActivityLog
    """ # noqa: E501
    configuration__description: Optional[StrictStr] = None
    configuration__id: Optional[StrictStr] = None
    configuration__name: Optional[StrictStr] = None
    configuration__version_id: Optional[StrictStr] = None
    count__artifacts: Optional[StrictInt] = None
    count__entities_updated: Optional[StrictInt] = None
    count__relationships_deleted: Optional[StrictInt] = None
    id: StrictStr
    instance__most_recent_instance_id: StrictStr
    instance__perspective: Optional[StrictStr] = None
    instance__state: Optional[StrictStr] = None
    instance__time_duration: Optional[StrictInt] = None
    instance__time_end: Optional[datetime] = None
    instance__time_start: Optional[datetime] = None
    matching_entity__detection: Optional[StrictStr] = None
    matching_entity__email: Optional[StrictStr] = None
    matching_entity__hostname: Optional[StrictStr] = None
    matching_entity__id: StrictStr
    matching_entity__ip: Optional[StrictStr] = None
    matching_entity__name: Optional[StrictStr] = None
    matching_entity__network: Optional[StrictStr] = None
    matching_entity__target: Optional[StrictStr] = None
    matching_entity__term: Optional[StrictStr] = None
    matching_entity__type: Optional[StrictStr] = None
    mitre__mitigations: Optional[List[StrictStr]] = None
    mitre__tactics: Optional[List[StrictStr]] = None
    mitre__techniques: Optional[List[StrictStr]] = None
    objective__attacker_perspective: Optional[StrictStr] = None
    objective__description: Optional[StrictStr] = None
    objective__implication: Optional[StrictStr] = None
    objective__status: Optional[StrictStr] = None
    org_id: StrictStr
    traffic_destination: Optional[StrictStr] = None
    traffic_destination_detail: Optional[Dict[str, Any]] = None
    traffic_source__ip_name: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = ["configuration__description", "configuration__id", "configuration__name", "configuration__version_id", "count__artifacts", "count__entities_updated", "count__relationships_deleted", "id", "instance__most_recent_instance_id", "instance__perspective", "instance__state", "instance__time_duration", "instance__time_end", "instance__time_start", "matching_entity__detection", "matching_entity__email", "matching_entity__hostname", "matching_entity__id", "matching_entity__ip", "matching_entity__name", "matching_entity__network", "matching_entity__target", "matching_entity__term", "matching_entity__type", "mitre__mitigations", "mitre__tactics", "mitre__techniques", "objective__attacker_perspective", "objective__description", "objective__implication", "objective__status", "org_id", "traffic_destination", "traffic_destination_detail", "traffic_source__ip_name"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of ActivityLog from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # set to None if configuration__description (nullable) is None
        # and model_fields_set contains the field
        if self.configuration__description is None and "configuration__description" in self.model_fields_set:
            _dict['configuration__description'] = None

        # set to None if configuration__id (nullable) is None
        # and model_fields_set contains the field
        if self.configuration__id is None and "configuration__id" in self.model_fields_set:
            _dict['configuration__id'] = None

        # set to None if configuration__name (nullable) is None
        # and model_fields_set contains the field
        if self.configuration__name is None and "configuration__name" in self.model_fields_set:
            _dict['configuration__name'] = None

        # set to None if configuration__version_id (nullable) is None
        # and model_fields_set contains the field
        if self.configuration__version_id is None and "configuration__version_id" in self.model_fields_set:
            _dict['configuration__version_id'] = None

        # set to None if count__artifacts (nullable) is None
        # and model_fields_set contains the field
        if self.count__artifacts is None and "count__artifacts" in self.model_fields_set:
            _dict['count__artifacts'] = None

        # set to None if count__entities_updated (nullable) is None
        # and model_fields_set contains the field
        if self.count__entities_updated is None and "count__entities_updated" in self.model_fields_set:
            _dict['count__entities_updated'] = None

        # set to None if count__relationships_deleted (nullable) is None
        # and model_fields_set contains the field
        if self.count__relationships_deleted is None and "count__relationships_deleted" in self.model_fields_set:
            _dict['count__relationships_deleted'] = None

        # set to None if instance__perspective (nullable) is None
        # and model_fields_set contains the field
        if self.instance__perspective is None and "instance__perspective" in self.model_fields_set:
            _dict['instance__perspective'] = None

        # set to None if instance__state (nullable) is None
        # and model_fields_set contains the field
        if self.instance__state is None and "instance__state" in self.model_fields_set:
            _dict['instance__state'] = None

        # set to None if instance__time_duration (nullable) is None
        # and model_fields_set contains the field
        if self.instance__time_duration is None and "instance__time_duration" in self.model_fields_set:
            _dict['instance__time_duration'] = None

        # set to None if instance__time_end (nullable) is None
        # and model_fields_set contains the field
        if self.instance__time_end is None and "instance__time_end" in self.model_fields_set:
            _dict['instance__time_end'] = None

        # set to None if instance__time_start (nullable) is None
        # and model_fields_set contains the field
        if self.instance__time_start is None and "instance__time_start" in self.model_fields_set:
            _dict['instance__time_start'] = None

        # set to None if matching_entity__detection (nullable) is None
        # and model_fields_set contains the field
        if self.matching_entity__detection is None and "matching_entity__detection" in self.model_fields_set:
            _dict['matching_entity__detection'] = None

        # set to None if matching_entity__email (nullable) is None
        # and model_fields_set contains the field
        if self.matching_entity__email is None and "matching_entity__email" in self.model_fields_set:
            _dict['matching_entity__email'] = None

        # set to None if matching_entity__hostname (nullable) is None
        # and model_fields_set contains the field
        if self.matching_entity__hostname is None and "matching_entity__hostname" in self.model_fields_set:
            _dict['matching_entity__hostname'] = None

        # set to None if matching_entity__ip (nullable) is None
        # and model_fields_set contains the field
        if self.matching_entity__ip is None and "matching_entity__ip" in self.model_fields_set:
            _dict['matching_entity__ip'] = None

        # set to None if matching_entity__name (nullable) is None
        # and model_fields_set contains the field
        if self.matching_entity__name is None and "matching_entity__name" in self.model_fields_set:
            _dict['matching_entity__name'] = None

        # set to None if matching_entity__network (nullable) is None
        # and model_fields_set contains the field
        if self.matching_entity__network is None and "matching_entity__network" in self.model_fields_set:
            _dict['matching_entity__network'] = None

        # set to None if matching_entity__target (nullable) is None
        # and model_fields_set contains the field
        if self.matching_entity__target is None and "matching_entity__target" in self.model_fields_set:
            _dict['matching_entity__target'] = None

        # set to None if matching_entity__term (nullable) is None
        # and model_fields_set contains the field
        if self.matching_entity__term is None and "matching_entity__term" in self.model_fields_set:
            _dict['matching_entity__term'] = None

        # set to None if matching_entity__type (nullable) is None
        # and model_fields_set contains the field
        if self.matching_entity__type is None and "matching_entity__type" in self.model_fields_set:
            _dict['matching_entity__type'] = None

        # set to None if mitre__mitigations (nullable) is None
        # and model_fields_set contains the field
        if self.mitre__mitigations is None and "mitre__mitigations" in self.model_fields_set:
            _dict['mitre__mitigations'] = None

        # set to None if mitre__tactics (nullable) is None
        # and model_fields_set contains the field
        if self.mitre__tactics is None and "mitre__tactics" in self.model_fields_set:
            _dict['mitre__tactics'] = None

        # set to None if mitre__techniques (nullable) is None
        # and model_fields_set contains the field
        if self.mitre__techniques is None and "mitre__techniques" in self.model_fields_set:
            _dict['mitre__techniques'] = None

        # set to None if objective__attacker_perspective (nullable) is None
        # and model_fields_set contains the field
        if self.objective__attacker_perspective is None and "objective__attacker_perspective" in self.model_fields_set:
            _dict['objective__attacker_perspective'] = None

        # set to None if objective__description (nullable) is None
        # and model_fields_set contains the field
        if self.objective__description is None and "objective__description" in self.model_fields_set:
            _dict['objective__description'] = None

        # set to None if objective__implication (nullable) is None
        # and model_fields_set contains the field
        if self.objective__implication is None and "objective__implication" in self.model_fields_set:
            _dict['objective__implication'] = None

        # set to None if objective__status (nullable) is None
        # and model_fields_set contains the field
        if self.objective__status is None and "objective__status" in self.model_fields_set:
            _dict['objective__status'] = None

        # set to None if traffic_destination (nullable) is None
        # and model_fields_set contains the field
        if self.traffic_destination is None and "traffic_destination" in self.model_fields_set:
            _dict['traffic_destination'] = None

        # set to None if traffic_destination_detail (nullable) is None
        # and model_fields_set contains the field
        if self.traffic_destination_detail is None and "traffic_destination_detail" in self.model_fields_set:
            _dict['traffic_destination_detail'] = None

        # set to None if traffic_source__ip_name (nullable) is None
        # and model_fields_set contains the field
        if self.traffic_source__ip_name is None and "traffic_source__ip_name" in self.model_fields_set:
            _dict['traffic_source__ip_name'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of ActivityLog from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "configuration__description": obj.get("configuration__description"),
            "configuration__id": obj.get("configuration__id"),
            "configuration__name": obj.get("configuration__name"),
            "configuration__version_id": obj.get("configuration__version_id"),
            "count__artifacts": obj.get("count__artifacts"),
            "count__entities_updated": obj.get("count__entities_updated"),
            "count__relationships_deleted": obj.get("count__relationships_deleted"),
            "id": obj.get("id"),
            "instance__most_recent_instance_id": obj.get("instance__most_recent_instance_id"),
            "instance__perspective": obj.get("instance__perspective"),
            "instance__state": obj.get("instance__state"),
            "instance__time_duration": obj.get("instance__time_duration"),
            "instance__time_end": obj.get("instance__time_end"),
            "instance__time_start": obj.get("instance__time_start"),
            "matching_entity__detection": obj.get("matching_entity__detection"),
            "matching_entity__email": obj.get("matching_entity__email"),
            "matching_entity__hostname": obj.get("matching_entity__hostname"),
            "matching_entity__id": obj.get("matching_entity__id"),
            "matching_entity__ip": obj.get("matching_entity__ip"),
            "matching_entity__name": obj.get("matching_entity__name"),
            "matching_entity__network": obj.get("matching_entity__network"),
            "matching_entity__target": obj.get("matching_entity__target"),
            "matching_entity__term": obj.get("matching_entity__term"),
            "matching_entity__type": obj.get("matching_entity__type"),
            "mitre__mitigations": obj.get("mitre__mitigations"),
            "mitre__tactics": obj.get("mitre__tactics"),
            "mitre__techniques": obj.get("mitre__techniques"),
            "objective__attacker_perspective": obj.get("objective__attacker_perspective"),
            "objective__description": obj.get("objective__description"),
            "objective__implication": obj.get("objective__implication"),
            "objective__status": obj.get("objective__status"),
            "org_id": obj.get("org_id"),
            "traffic_destination": obj.get("traffic_destination"),
            "traffic_destination_detail": obj.get("traffic_destination_detail"),
            "traffic_source__ip_name": obj.get("traffic_source__ip_name")
        })
        return _obj


